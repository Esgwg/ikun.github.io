<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/101002150?v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="[最强异常检测算法，自编码器 ！！](https://mp.weixin.qq.com/s/wvJM4sKsmCHJGchWJTz8zw)
；

```python
'''
autoencoder based anomaly detection model
'''
import torch
import torch.nn as nn
import torch.optim as optim
import torch.utils.data as Data
import numpy as np
import matplotlib.pyplot as plt
from sklearn import metrics
import copy
# plt.switch_backend('Agg')

from general_utils import DEVICE

epoches = 20
lr = 1e-4
weight_decay = 1.e-7
batch_size = 1024
percentage = 0.99

device = DEVICE
criterion = nn.MSELoss()
getMSEvec = nn.MSELoss(reduction='none')


class autoencoder(nn.Module):
    def __init__(self, feature_size, criter='rmse'): # criter = ['rmse', 'mse'] 
        super(autoencoder, self).__init__()
        self.encoder = nn.Sequential(nn.Linear(feature_size, int(feature_size*0.75)),
                                     nn.ReLU(True),
                                     nn.Linear(int(feature_size*0.75), int(feature_size*0.5)),
                                     nn.ReLU(True),
                                     nn.Linear(int(feature_size*0.5),int(feature_size*0.25)),
                                     nn.ReLU(True),
                                     nn.Linear(int(feature_size*0.25),int(feature_size*0.1)))

        self.decoder = nn.Sequential(nn.Linear(int(feature_size*0.1),int(feature_size*0.25)),
                                     nn.ReLU(True),
                                     nn.Linear(int(feature_size*0.25),int(feature_size*0.5)),
                                     nn.ReLU(True),
                                     nn.Linear(int(feature_size*0.5),int(feature_size*0.75)),
                                     nn.ReLU(True),
                                     nn.Linear(int(feature_size*0.75),int(feature_size)),
                                     )
        
        self.thres = np.Inf
        self.criter = criter
        print(f'NOTICE: use {self.criter} as the criteration of reconstruction error')

    def forward(self, x):
        encode = self.encoder(x)
        # print('encode', encode)
        decode = self.decoder(encode)
        # print('decode', decode)
        return decode
    
    # update anomaly detection threshold
    def update_thres(self, thres):
        self.thres = thres


def se2rmse(a):
    return torch.sqrt(sum(a.t())/a.shape[1])

def train(X_train, feature_size, epoches=epoches, lr=lr, percentage=percentage, weight_decay=weight_decay, verbose=True, thres_criter='rmse'):
    config = {
        'epoches': epoches,
        'lr':lr,
        'percentage':percentage,
        'weight_decay':weight_decay,
        'device':device,
    }
    if verbose:
        print('Hyper parameter config:', config)
        
    model = autoencoder(feature_size, thres_criter).to(device)
    optimizier = optim.Adam(model.parameters(), lr=lr, weight_decay=weight_decay)
    model.train()

    X_train = torch.from_numpy(X_train).type(torch.float).to(device)
    torch_dataset = Data.TensorDataset(X_train, X_train)
    loader = Data.DataLoader(
        dataset=torch_dataset,
        batch_size=batch_size,
        shuffle=True,
    )
    
    for epoch in range(epoches):
        for step, (batch_x, batch_y) in enumerate(loader):
            output = model(batch_x)
            loss = criterion(output, batch_y)
            optimizier.zero_grad()
            loss.backward()
            optimizier.step()
            # if step % 10 == 0 :
        if verbose:
            print('epoch:{}/{}'.format(epoch,epoches), '|Loss:', loss.item())
    
    model.eval()
    output = model(X_train)
    if thres_criter == 'rmse':
        mse_vec = getMSEvec(output,X_train)
        rmse_vec = se2rmse(mse_vec).cpu().data.numpy()
        if verbose:
            print('max AD score',max(rmse_vec))
        thres = max(rmse_vec)
        rmse_vec.sort()
        pctg = percentage
        thres = rmse_vec[int(len(rmse_vec)*pctg)]
    elif thres_criter == 'mse':
        mse_vec = torch.mean(getMSEvec(X_train, output), dim=1).cpu().data.numpy()
        if verbose:
            print('max AD score',max(mse_vec))
        thres = max(mse_vec)
        mse_vec.sort()
        pctg = percentage
        thres = mse_vec[int(len(mse_vec)*pctg)]
    else:
        print('Unknown criterion for selecting threshold', thres_criter)
        exit(-1)
        
    model.thres = thres
    if verbose:
        print(f'Threshold is: {thres} (at percentage {percentage})' )

    return model

# use X_valid to decide the best model
def train_valid(X_train, feature_size, X_valid, y_valid, 
                epoches=epoches, lr=lr, weight_decay=weight_decay, batch_size=batch_size, 
                percentage=0.99, thres_criter='rmse', verbose=True, debug=False, opt='Adam'):
    config = {
        'epoches': epoches,
        'lr':lr,
        'percentage':percentage,
        'weight_decay':weight_decay,
        'device':device,
    }
    if verbose:
        print('Hyper parameter config:', config)
        
    model = autoencoder(feature_size, thres_criter).to(device)
    if opt == 'Adam':
        optimizier = optim.Adam(model.parameters(), lr=lr, weight_decay=weight_decay)
    elif opt == 'SGD':
        optimizier = optim.SGD(model.parameters(), lr=lr)
    else: 
        raise RuntimeError(f'Unknown optimizier: {opt}')

    X_train = torch.from_numpy(X_train).type(torch.float).to(device)  
    torch_dataset = Data.TensorDataset(X_train, X_train)
    loader = Data.DataLoader(
        dataset=torch_dataset,
        batch_size=batch_size,
        shuffle=True,
    )
    
    best_model, best_auc, best_thres =  None, -np.Inf, None

    for epoch in range(epoches):
        model.train()
        for step, (batch_x, batch_y) in enumerate(loader):
            output = model(batch_x)
            loss = criterion(output, batch_y)
            optimizier.zero_grad()
            loss.backward()
            optimizier.step()
        if verbose:
            print('epoch:{}/{}'.format(epoch,epoches), '|Loss:', loss.item())

        model.eval()
        # get raw threshold for model 
        output = model(X_train)
        if thres_criter == 'rmse':
            mse_vec = getMSEvec(output,X_train)
            rmse_vec = se2rmse(mse_vec).cpu().data.numpy()
            thres = max(rmse_vec)
            rmse_vec.sort()
            pctg = percentage
            thres = rmse_vec[int(len(rmse_vec)*pctg)]
        elif thres_criter == 'mse':
            mse_vec = torch.mean(getMSEvec(X_train, output), dim=1).cpu().data.numpy()
            thres = max(mse_vec)
            mse_vec.sort()
            pctg = percentage
            thres = mse_vec[int(len(mse_vec)*pctg)]
        else:
            print('Unknown criterion for selecting threshold', thres_criter)
            exit(-1)
        model.thres = thres

        _, y_valid_rmse = test(model, X_valid)
        roc_auc, o_thres = eval_roc(y_valid_rmse, y_valid, thres_max=model.thres*1.5, plot=False, verbose=False)
        if roc_auc > best_auc:
            best_auc = roc_auc
            best_thres = o_thres
            best_model = copy.deepcopy(model)
            model.thres = best_thres
            y_valid_pred, _ = test(model, X_valid)
            tpr, fpr = TPR_FPR(y_valid_pred, y_valid, model.thres, verbose=False)
            if verbose: print(f'- update model! valid: roc auc is {best_auc:.5f}, tpr: {tpr:.5f}, fpr:{fpr:.5f}')
        elif debug:
            y_valid_pred, _ = test(model, X_valid)
            tpr, fpr = TPR_FPR(y_valid_pred, y_valid, o_thres, verbose=False)
            print(f'(- NOT update, valid: roc auc is {roc_auc:.5f}, tpr: {tpr:.5f}, fpr:{fpr:.5f})')

    if verbose:
        print(f'Threshold is: {model.thres} (at percentage {percentage})' )

    return best_model



def train_pos_sampling(X_train_ben, X_train_pos, feature_size, pos_weight = 1.,
                       epoches=epoches, lr=lr, weight_decay=weight_decay, batch_size=batch_size, 
                       percentage=0.99, thres_criter='rmse', verbose=True, debug=False, opt='Adam',
                       X_valid = None, y_valid = None, # if not None, will use validation set to choose best model
                       ):
    # clip to make sure X_train_pos and X_train_ben is with the same size
    if len(X_train_pos) >= len(X_train_ben):
        X_train_pos = X_train_pos[:len(X_train_ben)]
    else:
        repeats = -(-len(X_train_ben)//len(X_train_pos))
        X_train_pos = np.tile(X_train_pos, (repeats, 1))
        X_train_pos = X_train_pos[:len(X_train_ben)]

    config = {
        'epoches': epoches,
        'lr':lr,
        'percentage':percentage,
        'weight_decay':weight_decay,
        'device':device,
    }
    if verbose:
        print('Hyper parameter config:', config)
        
    model = autoencoder(feature_size, thres_criter).to(device)
    if opt == 'Adam':
        optimizier = optim.Adam(model.parameters(), lr=lr, weight_decay=weight_decay)
    elif opt == 'SGD':
        optimizier = optim.SGD(model.parameters(), lr=lr)
    else: 
        raise RuntimeError(f'Unknown optimizier: {opt}')

    X_train_ben = torch.from_numpy(X_train_ben).type(torch.float).to(device)
    X_train_pos = torch.from_numpy(X_train_pos).type(torch.float).to(device)

    torch_dataset = Data.TensorDataset(X_train_ben, X_train_pos)
    loader = Data.DataLoader(
        dataset=torch_dataset,
        batch_size=batch_size,
        shuffle=True,
    )
    
    best_model, best_auc, best_thres =  None, -np.Inf, None
    Bound = nn.ReLU()
    MAX_THRES = 4.
    
    for epoch in range(epoches):
        model.train()
        for step, (batch_x_neg, batch_x_pos) in enumerate(loader):
            output_neg = model(batch_x_neg)
            loss_neg = criterion(output_neg, batch_x_neg)
            output_pos = model(batch_x_pos)
            loss_pos = Bound(MAX_THRES-criterion(output_pos, batch_x_pos))
            loss = loss_neg + pos_weight * loss_pos
            optimizier.zero_grad()
            loss.backward()
            optimizier.step()

        if verbose:
            print('epoch:{}/{}'.format(epoch,epoches), '|Loss:', loss.item(), f'(neg: {loss_neg.item()}, pos:{loss_pos.item()})')

        if (X_valid is not None and y_valid is not None) or (epoch == epoches-1):
            model.eval()
            # get raw threshold for model 
            output = model(X_train_ben)
            if thres_criter == 'rmse':
                mse_vec = getMSEvec(output,X_train_ben)
                rmse_vec = se2rmse(mse_vec).cpu().data.numpy()
                thres = max(rmse_vec)
                rmse_vec.sort()
                pctg = percentage
                thres = rmse_vec[int(len(rmse_vec)*pctg)]
            elif thres_criter == 'mse':
                mse_vec = torch.mean(getMSEvec(X_train_ben, output), dim=1).cpu().data.numpy()
                thres = max(mse_vec)
                mse_vec.sort()
                pctg = percentage
                thres = mse_vec[int(len(mse_vec)*pctg)]
            else:
                print('Unknown criterion for selecting threshold', thres_criter)
                exit(-1)
            model.thres = thres

        if X_valid is not None and y_valid is not None:
            _, y_valid_rmse = test(model, X_valid)
            roc_auc, o_thres = eval_roc(y_valid_rmse, y_valid, thres_max=model.thres*1.5, plot=False, verbose=False)
            if roc_auc > best_auc:
                best_auc = roc_auc
                best_thres = o_thres
                best_model = copy.deepcopy(model)
                model.thres = best_thres
                y_valid_pred, _ = test(model, X_valid)
                tpr, fpr = TPR_FPR(y_valid_pred, y_valid, model.thres, verbose=False)
                if verbose: print(f'- update model! valid: roc auc is {best_auc:.5f}, tpr: {tpr:.5f}, fpr:{fpr:.5f}')
            elif debug:
                y_valid_pred, _ = test(model, X_valid)
                tpr, fpr = TPR_FPR(y_valid_pred, y_valid, o_thres, verbose=False)
                print(f'(- NOT update, valid: roc auc is {roc_auc:.5f}, tpr: {tpr:.5f}, fpr:{fpr:.5f})')
        else:
            best_model = model

    if verbose:
        print(f'Threshold is: {model.thres} (at percentage {percentage})' )

    return best_model


@torch.no_grad()
def test(model, X_test, thres=None):
    if thres is None:
        thres = model.thres 
    model.eval()
    X_test = torch.from_numpy(X_test).type(torch.float)    
    X_test = X_test.to(device)
    output = model(X_test)
    if model.criter == 'rmse':
        mse_vec = getMSEvec(output,X_test)
        rmse_vec = se2rmse(mse_vec).cpu().data.numpy()
        idx_mal = np.where(rmse_vec>thres)
        ano_score = rmse_vec
    elif model.criter == 'mse':
        mse_vec = torch.mean(getMSEvec(X_test, output), dim=1).cpu().data.numpy()
        idx_mal = np.where(mse_vec>thres)
        ano_score = mse_vec
    else:
        raise NotImplementedError
    
     
    y_pred = np.asarray([0] * len(ano_score))
    y_pred[idx_mal] = 1

    return y_pred, ano_score


def test_plot(rmse_vec, thres, file_name = None, label = None):
    plt.figure()
    plt.plot(np.linspace(0,len(rmse_vec)-1,len(rmse_vec)),[thres]*len(rmse_vec),c='black',label='99th-threshold')
    # plt.ylim(0,thres*2.)

    if label is not None:
        idx = np.where(label==0)[0]
        plt.scatter(idx, rmse_vec[idx], s=8, color='blue', alpha=0.4, label='Normal')
        
        idx = np.where(label==1)[0]
        plt.scatter(idx, rmse_vec[idx], s=8, color='red', alpha=0.7, label='Anomalies')
    else:
        plt.scatter(np.linspace(0,len(rmse_vec)-1,len(rmse_vec)),rmse_vec,s=8,alpha=0.4, label='Test samples' )
    
    plt.legend()
    plt.xlabel('Sample NO.')
    plt.ylabel('Anomaly Score (RMSE)')
    plt.title('Per-sample Score')
    if file_name is None:
        plt.show()
    else:
        plt.rcParams.update({'figure.dpi':300})
        plt.savefig(file_name)



def TPR_FPR(y_prob, y_true, thres, verbose=True): 
    y_true = np.asarray(y_true)
    y_prob = np.asarray(y_prob)
    y_pred = np.where(y_prob >= thres, 1, 0)

    fp = np.sum((y_pred == 1) & (y_true == 0))
    tp = np.sum((y_pred == 1) & (y_true == 1))
    fn = np.sum((y_pred == 0) & (y_true == 1))
    tn = np.sum((y_pred == 0) & (y_true == 0))

    fpr = (fp / (fp + tn + 1e-10))
    tpr = (tp / (tp + fn + 1e-10))
    
    if verbose:
        print('TPR:', tpr, 'FPR:', fpr,)
        print('TN:', tn, 'TP:', tp, 'FP:', fp, 'FN:', fn)
        
    return tpr, fpr


def multi_fpr_tpr(y_prob, y_true, thres_max, thres_min=0, split = 300, is_P_mal=True): 
    y_true = np.asarray(y_true)
    y_prob = np.asarray(y_prob)
    fpr = []
    tpr = []

    thresholds = np.linspace(thres_min, thres_max, split)
    for threshold in thresholds:
        if is_P_mal: 
            y_pred = np.where(y_prob >= threshold, 1, 0)
        else:
            y_pred = np.where(y_prob <= threshold, 1, 0)

        fp = np.sum((y_pred == 1) & (y_true == 0))
        tp = np.sum((y_pred == 1) & (y_true == 1))

        fn = np.sum((y_pred == 0) & (y_true == 1))
        tn = np.sum((y_pred == 0) & (y_true == 0))

        # print('fp+tn', fp+tn, 'tp + fn', tp + fn)
        fpr.append(fp / (fp + tn))
        tpr.append(tp / (tp + fn))

    return fpr, tpr, thresholds

def eval_roc(probs, labels, thres_max, thres_min=0, split=300, is_P_mal=True, plot=True, verbose=True):
    fprs, tprs, thresholds = multi_fpr_tpr(probs, labels, thres_max, thres_min=thres_min, split=split, is_P_mal=is_P_mal)
    roc_auc = metrics.auc(fprs, tprs)
    if verbose: print('roc_auc:',roc_auc)
    
    if plot:
        plt.figure()
        plt.title('Receiver Operating Characteristic')
        plt.plot(fprs, tprs, 'b', label = 'AUC = %0.2f' % roc_auc)
        plt.legend(loc = 'lower right')
        plt.xlim([0, 1])
        plt.ylim([0, 1])
        plt.ylabel('True Positive Rate')
        plt.xlabel('False Positive Rate')
        plt.show()
    
    optimal_idx = np.argmax(np.asarray(tprs) - np.asarray(fprs))
    optimal_threshold = thresholds[optimal_idx]
    return roc_auc, optimal_threshold

class Normalizer:
    def __init__(self, train_data, clip=False, delta=1e-10):
        self.train_min = np.min(train_data, axis=0)
        self.train_max = np.max(train_data, axis=0)
        self.clip = clip
        self.delta = delta

    def transform(self, data):
        return (data - self.train_min) / (self.train_max - self.train_min + self.delta)

    def denorm(self, data):
        return data * (self.train_max - self.train_min) + self.train_min

    def denorm_query(self, index, norm_value):
        range = self.train_max[index] - self.train_min[index]
        return norm_value * range + self.train_min[index]。">
<meta property="og:title" content="最强异常检测算法，自编码器 ！！；AutoEncoder.py">
<meta property="og:description" content="[最强异常检测算法，自编码器 ！！](https://mp.weixin.qq.com/s/wvJM4sKsmCHJGchWJTz8zw)
；

```python
'''
autoencoder based anomaly detection model
'''
import torch
import torch.nn as nn
import torch.optim as optim
import torch.utils.data as Data
import numpy as np
import matplotlib.pyplot as plt
from sklearn import metrics
import copy
# plt.switch_backend('Agg')

from general_utils import DEVICE

epoches = 20
lr = 1e-4
weight_decay = 1.e-7
batch_size = 1024
percentage = 0.99

device = DEVICE
criterion = nn.MSELoss()
getMSEvec = nn.MSELoss(reduction='none')


class autoencoder(nn.Module):
    def __init__(self, feature_size, criter='rmse'): # criter = ['rmse', 'mse'] 
        super(autoencoder, self).__init__()
        self.encoder = nn.Sequential(nn.Linear(feature_size, int(feature_size*0.75)),
                                     nn.ReLU(True),
                                     nn.Linear(int(feature_size*0.75), int(feature_size*0.5)),
                                     nn.ReLU(True),
                                     nn.Linear(int(feature_size*0.5),int(feature_size*0.25)),
                                     nn.ReLU(True),
                                     nn.Linear(int(feature_size*0.25),int(feature_size*0.1)))

        self.decoder = nn.Sequential(nn.Linear(int(feature_size*0.1),int(feature_size*0.25)),
                                     nn.ReLU(True),
                                     nn.Linear(int(feature_size*0.25),int(feature_size*0.5)),
                                     nn.ReLU(True),
                                     nn.Linear(int(feature_size*0.5),int(feature_size*0.75)),
                                     nn.ReLU(True),
                                     nn.Linear(int(feature_size*0.75),int(feature_size)),
                                     )
        
        self.thres = np.Inf
        self.criter = criter
        print(f'NOTICE: use {self.criter} as the criteration of reconstruction error')

    def forward(self, x):
        encode = self.encoder(x)
        # print('encode', encode)
        decode = self.decoder(encode)
        # print('decode', decode)
        return decode
    
    # update anomaly detection threshold
    def update_thres(self, thres):
        self.thres = thres


def se2rmse(a):
    return torch.sqrt(sum(a.t())/a.shape[1])

def train(X_train, feature_size, epoches=epoches, lr=lr, percentage=percentage, weight_decay=weight_decay, verbose=True, thres_criter='rmse'):
    config = {
        'epoches': epoches,
        'lr':lr,
        'percentage':percentage,
        'weight_decay':weight_decay,
        'device':device,
    }
    if verbose:
        print('Hyper parameter config:', config)
        
    model = autoencoder(feature_size, thres_criter).to(device)
    optimizier = optim.Adam(model.parameters(), lr=lr, weight_decay=weight_decay)
    model.train()

    X_train = torch.from_numpy(X_train).type(torch.float).to(device)
    torch_dataset = Data.TensorDataset(X_train, X_train)
    loader = Data.DataLoader(
        dataset=torch_dataset,
        batch_size=batch_size,
        shuffle=True,
    )
    
    for epoch in range(epoches):
        for step, (batch_x, batch_y) in enumerate(loader):
            output = model(batch_x)
            loss = criterion(output, batch_y)
            optimizier.zero_grad()
            loss.backward()
            optimizier.step()
            # if step % 10 == 0 :
        if verbose:
            print('epoch:{}/{}'.format(epoch,epoches), '|Loss:', loss.item())
    
    model.eval()
    output = model(X_train)
    if thres_criter == 'rmse':
        mse_vec = getMSEvec(output,X_train)
        rmse_vec = se2rmse(mse_vec).cpu().data.numpy()
        if verbose:
            print('max AD score',max(rmse_vec))
        thres = max(rmse_vec)
        rmse_vec.sort()
        pctg = percentage
        thres = rmse_vec[int(len(rmse_vec)*pctg)]
    elif thres_criter == 'mse':
        mse_vec = torch.mean(getMSEvec(X_train, output), dim=1).cpu().data.numpy()
        if verbose:
            print('max AD score',max(mse_vec))
        thres = max(mse_vec)
        mse_vec.sort()
        pctg = percentage
        thres = mse_vec[int(len(mse_vec)*pctg)]
    else:
        print('Unknown criterion for selecting threshold', thres_criter)
        exit(-1)
        
    model.thres = thres
    if verbose:
        print(f'Threshold is: {thres} (at percentage {percentage})' )

    return model

# use X_valid to decide the best model
def train_valid(X_train, feature_size, X_valid, y_valid, 
                epoches=epoches, lr=lr, weight_decay=weight_decay, batch_size=batch_size, 
                percentage=0.99, thres_criter='rmse', verbose=True, debug=False, opt='Adam'):
    config = {
        'epoches': epoches,
        'lr':lr,
        'percentage':percentage,
        'weight_decay':weight_decay,
        'device':device,
    }
    if verbose:
        print('Hyper parameter config:', config)
        
    model = autoencoder(feature_size, thres_criter).to(device)
    if opt == 'Adam':
        optimizier = optim.Adam(model.parameters(), lr=lr, weight_decay=weight_decay)
    elif opt == 'SGD':
        optimizier = optim.SGD(model.parameters(), lr=lr)
    else: 
        raise RuntimeError(f'Unknown optimizier: {opt}')

    X_train = torch.from_numpy(X_train).type(torch.float).to(device)  
    torch_dataset = Data.TensorDataset(X_train, X_train)
    loader = Data.DataLoader(
        dataset=torch_dataset,
        batch_size=batch_size,
        shuffle=True,
    )
    
    best_model, best_auc, best_thres =  None, -np.Inf, None

    for epoch in range(epoches):
        model.train()
        for step, (batch_x, batch_y) in enumerate(loader):
            output = model(batch_x)
            loss = criterion(output, batch_y)
            optimizier.zero_grad()
            loss.backward()
            optimizier.step()
        if verbose:
            print('epoch:{}/{}'.format(epoch,epoches), '|Loss:', loss.item())

        model.eval()
        # get raw threshold for model 
        output = model(X_train)
        if thres_criter == 'rmse':
            mse_vec = getMSEvec(output,X_train)
            rmse_vec = se2rmse(mse_vec).cpu().data.numpy()
            thres = max(rmse_vec)
            rmse_vec.sort()
            pctg = percentage
            thres = rmse_vec[int(len(rmse_vec)*pctg)]
        elif thres_criter == 'mse':
            mse_vec = torch.mean(getMSEvec(X_train, output), dim=1).cpu().data.numpy()
            thres = max(mse_vec)
            mse_vec.sort()
            pctg = percentage
            thres = mse_vec[int(len(mse_vec)*pctg)]
        else:
            print('Unknown criterion for selecting threshold', thres_criter)
            exit(-1)
        model.thres = thres

        _, y_valid_rmse = test(model, X_valid)
        roc_auc, o_thres = eval_roc(y_valid_rmse, y_valid, thres_max=model.thres*1.5, plot=False, verbose=False)
        if roc_auc > best_auc:
            best_auc = roc_auc
            best_thres = o_thres
            best_model = copy.deepcopy(model)
            model.thres = best_thres
            y_valid_pred, _ = test(model, X_valid)
            tpr, fpr = TPR_FPR(y_valid_pred, y_valid, model.thres, verbose=False)
            if verbose: print(f'- update model! valid: roc auc is {best_auc:.5f}, tpr: {tpr:.5f}, fpr:{fpr:.5f}')
        elif debug:
            y_valid_pred, _ = test(model, X_valid)
            tpr, fpr = TPR_FPR(y_valid_pred, y_valid, o_thres, verbose=False)
            print(f'(- NOT update, valid: roc auc is {roc_auc:.5f}, tpr: {tpr:.5f}, fpr:{fpr:.5f})')

    if verbose:
        print(f'Threshold is: {model.thres} (at percentage {percentage})' )

    return best_model



def train_pos_sampling(X_train_ben, X_train_pos, feature_size, pos_weight = 1.,
                       epoches=epoches, lr=lr, weight_decay=weight_decay, batch_size=batch_size, 
                       percentage=0.99, thres_criter='rmse', verbose=True, debug=False, opt='Adam',
                       X_valid = None, y_valid = None, # if not None, will use validation set to choose best model
                       ):
    # clip to make sure X_train_pos and X_train_ben is with the same size
    if len(X_train_pos) >= len(X_train_ben):
        X_train_pos = X_train_pos[:len(X_train_ben)]
    else:
        repeats = -(-len(X_train_ben)//len(X_train_pos))
        X_train_pos = np.tile(X_train_pos, (repeats, 1))
        X_train_pos = X_train_pos[:len(X_train_ben)]

    config = {
        'epoches': epoches,
        'lr':lr,
        'percentage':percentage,
        'weight_decay':weight_decay,
        'device':device,
    }
    if verbose:
        print('Hyper parameter config:', config)
        
    model = autoencoder(feature_size, thres_criter).to(device)
    if opt == 'Adam':
        optimizier = optim.Adam(model.parameters(), lr=lr, weight_decay=weight_decay)
    elif opt == 'SGD':
        optimizier = optim.SGD(model.parameters(), lr=lr)
    else: 
        raise RuntimeError(f'Unknown optimizier: {opt}')

    X_train_ben = torch.from_numpy(X_train_ben).type(torch.float).to(device)
    X_train_pos = torch.from_numpy(X_train_pos).type(torch.float).to(device)

    torch_dataset = Data.TensorDataset(X_train_ben, X_train_pos)
    loader = Data.DataLoader(
        dataset=torch_dataset,
        batch_size=batch_size,
        shuffle=True,
    )
    
    best_model, best_auc, best_thres =  None, -np.Inf, None
    Bound = nn.ReLU()
    MAX_THRES = 4.
    
    for epoch in range(epoches):
        model.train()
        for step, (batch_x_neg, batch_x_pos) in enumerate(loader):
            output_neg = model(batch_x_neg)
            loss_neg = criterion(output_neg, batch_x_neg)
            output_pos = model(batch_x_pos)
            loss_pos = Bound(MAX_THRES-criterion(output_pos, batch_x_pos))
            loss = loss_neg + pos_weight * loss_pos
            optimizier.zero_grad()
            loss.backward()
            optimizier.step()

        if verbose:
            print('epoch:{}/{}'.format(epoch,epoches), '|Loss:', loss.item(), f'(neg: {loss_neg.item()}, pos:{loss_pos.item()})')

        if (X_valid is not None and y_valid is not None) or (epoch == epoches-1):
            model.eval()
            # get raw threshold for model 
            output = model(X_train_ben)
            if thres_criter == 'rmse':
                mse_vec = getMSEvec(output,X_train_ben)
                rmse_vec = se2rmse(mse_vec).cpu().data.numpy()
                thres = max(rmse_vec)
                rmse_vec.sort()
                pctg = percentage
                thres = rmse_vec[int(len(rmse_vec)*pctg)]
            elif thres_criter == 'mse':
                mse_vec = torch.mean(getMSEvec(X_train_ben, output), dim=1).cpu().data.numpy()
                thres = max(mse_vec)
                mse_vec.sort()
                pctg = percentage
                thres = mse_vec[int(len(mse_vec)*pctg)]
            else:
                print('Unknown criterion for selecting threshold', thres_criter)
                exit(-1)
            model.thres = thres

        if X_valid is not None and y_valid is not None:
            _, y_valid_rmse = test(model, X_valid)
            roc_auc, o_thres = eval_roc(y_valid_rmse, y_valid, thres_max=model.thres*1.5, plot=False, verbose=False)
            if roc_auc > best_auc:
                best_auc = roc_auc
                best_thres = o_thres
                best_model = copy.deepcopy(model)
                model.thres = best_thres
                y_valid_pred, _ = test(model, X_valid)
                tpr, fpr = TPR_FPR(y_valid_pred, y_valid, model.thres, verbose=False)
                if verbose: print(f'- update model! valid: roc auc is {best_auc:.5f}, tpr: {tpr:.5f}, fpr:{fpr:.5f}')
            elif debug:
                y_valid_pred, _ = test(model, X_valid)
                tpr, fpr = TPR_FPR(y_valid_pred, y_valid, o_thres, verbose=False)
                print(f'(- NOT update, valid: roc auc is {roc_auc:.5f}, tpr: {tpr:.5f}, fpr:{fpr:.5f})')
        else:
            best_model = model

    if verbose:
        print(f'Threshold is: {model.thres} (at percentage {percentage})' )

    return best_model


@torch.no_grad()
def test(model, X_test, thres=None):
    if thres is None:
        thres = model.thres 
    model.eval()
    X_test = torch.from_numpy(X_test).type(torch.float)    
    X_test = X_test.to(device)
    output = model(X_test)
    if model.criter == 'rmse':
        mse_vec = getMSEvec(output,X_test)
        rmse_vec = se2rmse(mse_vec).cpu().data.numpy()
        idx_mal = np.where(rmse_vec>thres)
        ano_score = rmse_vec
    elif model.criter == 'mse':
        mse_vec = torch.mean(getMSEvec(X_test, output), dim=1).cpu().data.numpy()
        idx_mal = np.where(mse_vec>thres)
        ano_score = mse_vec
    else:
        raise NotImplementedError
    
     
    y_pred = np.asarray([0] * len(ano_score))
    y_pred[idx_mal] = 1

    return y_pred, ano_score


def test_plot(rmse_vec, thres, file_name = None, label = None):
    plt.figure()
    plt.plot(np.linspace(0,len(rmse_vec)-1,len(rmse_vec)),[thres]*len(rmse_vec),c='black',label='99th-threshold')
    # plt.ylim(0,thres*2.)

    if label is not None:
        idx = np.where(label==0)[0]
        plt.scatter(idx, rmse_vec[idx], s=8, color='blue', alpha=0.4, label='Normal')
        
        idx = np.where(label==1)[0]
        plt.scatter(idx, rmse_vec[idx], s=8, color='red', alpha=0.7, label='Anomalies')
    else:
        plt.scatter(np.linspace(0,len(rmse_vec)-1,len(rmse_vec)),rmse_vec,s=8,alpha=0.4, label='Test samples' )
    
    plt.legend()
    plt.xlabel('Sample NO.')
    plt.ylabel('Anomaly Score (RMSE)')
    plt.title('Per-sample Score')
    if file_name is None:
        plt.show()
    else:
        plt.rcParams.update({'figure.dpi':300})
        plt.savefig(file_name)



def TPR_FPR(y_prob, y_true, thres, verbose=True): 
    y_true = np.asarray(y_true)
    y_prob = np.asarray(y_prob)
    y_pred = np.where(y_prob >= thres, 1, 0)

    fp = np.sum((y_pred == 1) & (y_true == 0))
    tp = np.sum((y_pred == 1) & (y_true == 1))
    fn = np.sum((y_pred == 0) & (y_true == 1))
    tn = np.sum((y_pred == 0) & (y_true == 0))

    fpr = (fp / (fp + tn + 1e-10))
    tpr = (tp / (tp + fn + 1e-10))
    
    if verbose:
        print('TPR:', tpr, 'FPR:', fpr,)
        print('TN:', tn, 'TP:', tp, 'FP:', fp, 'FN:', fn)
        
    return tpr, fpr


def multi_fpr_tpr(y_prob, y_true, thres_max, thres_min=0, split = 300, is_P_mal=True): 
    y_true = np.asarray(y_true)
    y_prob = np.asarray(y_prob)
    fpr = []
    tpr = []

    thresholds = np.linspace(thres_min, thres_max, split)
    for threshold in thresholds:
        if is_P_mal: 
            y_pred = np.where(y_prob >= threshold, 1, 0)
        else:
            y_pred = np.where(y_prob <= threshold, 1, 0)

        fp = np.sum((y_pred == 1) & (y_true == 0))
        tp = np.sum((y_pred == 1) & (y_true == 1))

        fn = np.sum((y_pred == 0) & (y_true == 1))
        tn = np.sum((y_pred == 0) & (y_true == 0))

        # print('fp+tn', fp+tn, 'tp + fn', tp + fn)
        fpr.append(fp / (fp + tn))
        tpr.append(tp / (tp + fn))

    return fpr, tpr, thresholds

def eval_roc(probs, labels, thres_max, thres_min=0, split=300, is_P_mal=True, plot=True, verbose=True):
    fprs, tprs, thresholds = multi_fpr_tpr(probs, labels, thres_max, thres_min=thres_min, split=split, is_P_mal=is_P_mal)
    roc_auc = metrics.auc(fprs, tprs)
    if verbose: print('roc_auc:',roc_auc)
    
    if plot:
        plt.figure()
        plt.title('Receiver Operating Characteristic')
        plt.plot(fprs, tprs, 'b', label = 'AUC = %0.2f' % roc_auc)
        plt.legend(loc = 'lower right')
        plt.xlim([0, 1])
        plt.ylim([0, 1])
        plt.ylabel('True Positive Rate')
        plt.xlabel('False Positive Rate')
        plt.show()
    
    optimal_idx = np.argmax(np.asarray(tprs) - np.asarray(fprs))
    optimal_threshold = thresholds[optimal_idx]
    return roc_auc, optimal_threshold

class Normalizer:
    def __init__(self, train_data, clip=False, delta=1e-10):
        self.train_min = np.min(train_data, axis=0)
        self.train_max = np.max(train_data, axis=0)
        self.clip = clip
        self.delta = delta

    def transform(self, data):
        return (data - self.train_min) / (self.train_max - self.train_min + self.delta)

    def denorm(self, data):
        return data * (self.train_max - self.train_min) + self.train_min

    def denorm_query(self, index, norm_value):
        range = self.train_max[index] - self.train_min[index]
        return norm_value * range + self.train_min[index]。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://Esgwg.github.io/ikun.github.io/post/zui-qiang-yi-chang-jian-ce-suan-fa-%EF%BC%8C-zi-bian-ma-qi-%20%EF%BC%81%EF%BC%81%EF%BC%9BAutoEncoder.py.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/101002150?v=4">
<title>最强异常检测算法，自编码器 ！！；AutoEncoder.py</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">最强异常检测算法，自编码器 ！！；AutoEncoder.py</h1>
<div class="title-right">
    <a href="https://Esgwg.github.io/ikun.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/Esgwg/ikun.github.io/issues/7" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p><a href="https://mp.weixin.qq.com/s/wvJM4sKsmCHJGchWJTz8zw" rel="nofollow">最强异常检测算法，自编码器 ！！</a><br>
；</p>
<div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-s">'''</span>
<span class="pl-s">autoencoder based anomaly detection model</span>
<span class="pl-s">'''</span>
<span class="pl-k">import</span> <span class="pl-s1">torch</span>
<span class="pl-k">import</span> <span class="pl-s1">torch</span>.<span class="pl-s1">nn</span> <span class="pl-k">as</span> <span class="pl-s1">nn</span>
<span class="pl-k">import</span> <span class="pl-s1">torch</span>.<span class="pl-s1">optim</span> <span class="pl-k">as</span> <span class="pl-s1">optim</span>
<span class="pl-k">import</span> <span class="pl-s1">torch</span>.<span class="pl-s1">utils</span>.<span class="pl-s1">data</span> <span class="pl-k">as</span> <span class="pl-v">Data</span>
<span class="pl-k">import</span> <span class="pl-s1">numpy</span> <span class="pl-k">as</span> <span class="pl-s1">np</span>
<span class="pl-k">import</span> <span class="pl-s1">matplotlib</span>.<span class="pl-s1">pyplot</span> <span class="pl-k">as</span> <span class="pl-s1">plt</span>
<span class="pl-k">from</span> <span class="pl-s1">sklearn</span> <span class="pl-k">import</span> <span class="pl-s1">metrics</span>
<span class="pl-k">import</span> <span class="pl-s1">copy</span>
<span class="pl-c"># plt.switch_backend('Agg')</span>

<span class="pl-k">from</span> <span class="pl-s1">general_utils</span> <span class="pl-k">import</span> <span class="pl-c1">DEVICE</span>

<span class="pl-s1">epoches</span> <span class="pl-c1">=</span> <span class="pl-c1">20</span>
<span class="pl-s1">lr</span> <span class="pl-c1">=</span> <span class="pl-c1">1e-4</span>
<span class="pl-s1">weight_decay</span> <span class="pl-c1">=</span> <span class="pl-c1">1.e-7</span>
<span class="pl-s1">batch_size</span> <span class="pl-c1">=</span> <span class="pl-c1">1024</span>
<span class="pl-s1">percentage</span> <span class="pl-c1">=</span> <span class="pl-c1">0.99</span>

<span class="pl-s1">device</span> <span class="pl-c1">=</span> <span class="pl-c1">DEVICE</span>
<span class="pl-s1">criterion</span> <span class="pl-c1">=</span> <span class="pl-s1">nn</span>.<span class="pl-c1">MSELoss</span>()
<span class="pl-s1">getMSEvec</span> <span class="pl-c1">=</span> <span class="pl-s1">nn</span>.<span class="pl-c1">MSELoss</span>(<span class="pl-s1">reduction</span><span class="pl-c1">=</span><span class="pl-s">'none'</span>)


<span class="pl-k">class</span> <span class="pl-s1">autoencoder</span>(<span class="pl-s1">nn</span>.<span class="pl-c1">Module</span>):
    <span class="pl-k">def</span> <span class="pl-en">__init__</span>(<span class="pl-s1">self</span>, <span class="pl-s1">feature_size</span>, <span class="pl-s1">criter</span><span class="pl-c1">=</span><span class="pl-s">'rmse'</span>): <span class="pl-c"># criter = ['rmse', 'mse'] </span>
        <span class="pl-en">super</span>(<span class="pl-s1">autoencoder</span>, <span class="pl-s1">self</span>).<span class="pl-c1">__init__</span>()
        <span class="pl-s1">self</span>.<span class="pl-c1">encoder</span> <span class="pl-c1">=</span> <span class="pl-s1">nn</span>.<span class="pl-c1">Sequential</span>(<span class="pl-s1">nn</span>.<span class="pl-c1">Linear</span>(<span class="pl-s1">feature_size</span>, <span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.75</span>)),
                                     <span class="pl-s1">nn</span>.<span class="pl-c1">ReLU</span>(<span class="pl-c1">True</span>),
                                     <span class="pl-s1">nn</span>.<span class="pl-c1">Linear</span>(<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.75</span>), <span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.5</span>)),
                                     <span class="pl-s1">nn</span>.<span class="pl-c1">ReLU</span>(<span class="pl-c1">True</span>),
                                     <span class="pl-s1">nn</span>.<span class="pl-c1">Linear</span>(<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.5</span>),<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.25</span>)),
                                     <span class="pl-s1">nn</span>.<span class="pl-c1">ReLU</span>(<span class="pl-c1">True</span>),
                                     <span class="pl-s1">nn</span>.<span class="pl-c1">Linear</span>(<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.25</span>),<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.1</span>)))

        <span class="pl-s1">self</span>.<span class="pl-c1">decoder</span> <span class="pl-c1">=</span> <span class="pl-s1">nn</span>.<span class="pl-c1">Sequential</span>(<span class="pl-s1">nn</span>.<span class="pl-c1">Linear</span>(<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.1</span>),<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.25</span>)),
                                     <span class="pl-s1">nn</span>.<span class="pl-c1">ReLU</span>(<span class="pl-c1">True</span>),
                                     <span class="pl-s1">nn</span>.<span class="pl-c1">Linear</span>(<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.25</span>),<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.5</span>)),
                                     <span class="pl-s1">nn</span>.<span class="pl-c1">ReLU</span>(<span class="pl-c1">True</span>),
                                     <span class="pl-s1">nn</span>.<span class="pl-c1">Linear</span>(<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.5</span>),<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.75</span>)),
                                     <span class="pl-s1">nn</span>.<span class="pl-c1">ReLU</span>(<span class="pl-c1">True</span>),
                                     <span class="pl-s1">nn</span>.<span class="pl-c1">Linear</span>(<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span><span class="pl-c1">*</span><span class="pl-c1">0.75</span>),<span class="pl-en">int</span>(<span class="pl-s1">feature_size</span>)),
                                     )
        
        <span class="pl-s1">self</span>.<span class="pl-c1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">Inf</span>
        <span class="pl-s1">self</span>.<span class="pl-c1">criter</span> <span class="pl-c1">=</span> <span class="pl-s1">criter</span>
        <span class="pl-en">print</span>(<span class="pl-s">f'NOTICE: use <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">self</span>.<span class="pl-c1">criter</span><span class="pl-kos">}</span></span> as the criteration of reconstruction error'</span>)

    <span class="pl-k">def</span> <span class="pl-en">forward</span>(<span class="pl-s1">self</span>, <span class="pl-s1">x</span>):
        <span class="pl-s1">encode</span> <span class="pl-c1">=</span> <span class="pl-s1">self</span>.<span class="pl-c1">encoder</span>(<span class="pl-s1">x</span>)
        <span class="pl-c"># print('encode', encode)</span>
        <span class="pl-s1">decode</span> <span class="pl-c1">=</span> <span class="pl-s1">self</span>.<span class="pl-c1">decoder</span>(<span class="pl-s1">encode</span>)
        <span class="pl-c"># print('decode', decode)</span>
        <span class="pl-k">return</span> <span class="pl-s1">decode</span>
    
    <span class="pl-c"># update anomaly detection threshold</span>
    <span class="pl-k">def</span> <span class="pl-en">update_thres</span>(<span class="pl-s1">self</span>, <span class="pl-s1">thres</span>):
        <span class="pl-s1">self</span>.<span class="pl-c1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">thres</span>


<span class="pl-k">def</span> <span class="pl-en">se2rmse</span>(<span class="pl-s1">a</span>):
    <span class="pl-k">return</span> <span class="pl-s1">torch</span>.<span class="pl-c1">sqrt</span>(<span class="pl-en">sum</span>(<span class="pl-s1">a</span>.<span class="pl-c1">t</span>())<span class="pl-c1">/</span><span class="pl-s1">a</span>.<span class="pl-c1">shape</span>[<span class="pl-c1">1</span>])

<span class="pl-k">def</span> <span class="pl-en">train</span>(<span class="pl-v">X_train</span>, <span class="pl-s1">feature_size</span>, <span class="pl-s1">epoches</span><span class="pl-c1">=</span><span class="pl-s1">epoches</span>, <span class="pl-s1">lr</span><span class="pl-c1">=</span><span class="pl-s1">lr</span>, <span class="pl-s1">percentage</span><span class="pl-c1">=</span><span class="pl-s1">percentage</span>, <span class="pl-s1">weight_decay</span><span class="pl-c1">=</span><span class="pl-s1">weight_decay</span>, <span class="pl-s1">verbose</span><span class="pl-c1">=</span><span class="pl-c1">True</span>, <span class="pl-s1">thres_criter</span><span class="pl-c1">=</span><span class="pl-s">'rmse'</span>):
    <span class="pl-s1">config</span> <span class="pl-c1">=</span> {
        <span class="pl-s">'epoches'</span>: <span class="pl-s1">epoches</span>,
        <span class="pl-s">'lr'</span>:<span class="pl-s1">lr</span>,
        <span class="pl-s">'percentage'</span>:<span class="pl-s1">percentage</span>,
        <span class="pl-s">'weight_decay'</span>:<span class="pl-s1">weight_decay</span>,
        <span class="pl-s">'device'</span>:<span class="pl-s1">device</span>,
    }
    <span class="pl-k">if</span> <span class="pl-s1">verbose</span>:
        <span class="pl-en">print</span>(<span class="pl-s">"Hyper parameter config:"</span>, <span class="pl-s1">config</span>)
        
    <span class="pl-s1">model</span> <span class="pl-c1">=</span> <span class="pl-en">autoencoder</span>(<span class="pl-s1">feature_size</span>, <span class="pl-s1">thres_criter</span>).<span class="pl-c1">to</span>(<span class="pl-s1">device</span>)
    <span class="pl-s1">optimizier</span> <span class="pl-c1">=</span> <span class="pl-s1">optim</span>.<span class="pl-c1">Adam</span>(<span class="pl-s1">model</span>.<span class="pl-c1">parameters</span>(), <span class="pl-s1">lr</span><span class="pl-c1">=</span><span class="pl-s1">lr</span>, <span class="pl-s1">weight_decay</span><span class="pl-c1">=</span><span class="pl-s1">weight_decay</span>)
    <span class="pl-s1">model</span>.<span class="pl-c1">train</span>()

    <span class="pl-v">X_train</span> <span class="pl-c1">=</span> <span class="pl-s1">torch</span>.<span class="pl-c1">from_numpy</span>(<span class="pl-v">X_train</span>).<span class="pl-c1">type</span>(<span class="pl-s1">torch</span>.<span class="pl-c1">float</span>).<span class="pl-c1">to</span>(<span class="pl-s1">device</span>)
    <span class="pl-s1">torch_dataset</span> <span class="pl-c1">=</span> <span class="pl-v">Data</span>.<span class="pl-c1">TensorDataset</span>(<span class="pl-v">X_train</span>, <span class="pl-v">X_train</span>)
    <span class="pl-s1">loader</span> <span class="pl-c1">=</span> <span class="pl-v">Data</span>.<span class="pl-c1">DataLoader</span>(
        <span class="pl-s1">dataset</span><span class="pl-c1">=</span><span class="pl-s1">torch_dataset</span>,
        <span class="pl-s1">batch_size</span><span class="pl-c1">=</span><span class="pl-s1">batch_size</span>,
        <span class="pl-s1">shuffle</span><span class="pl-c1">=</span><span class="pl-c1">True</span>,
    )
    
    <span class="pl-k">for</span> <span class="pl-s1">epoch</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-s1">epoches</span>):
        <span class="pl-k">for</span> <span class="pl-s1">step</span>, (<span class="pl-s1">batch_x</span>, <span class="pl-s1">batch_y</span>) <span class="pl-c1">in</span> <span class="pl-en">enumerate</span>(<span class="pl-s1">loader</span>):
            <span class="pl-s1">output</span> <span class="pl-c1">=</span> <span class="pl-en">model</span>(<span class="pl-s1">batch_x</span>)
            <span class="pl-s1">loss</span> <span class="pl-c1">=</span> <span class="pl-en">criterion</span>(<span class="pl-s1">output</span>, <span class="pl-s1">batch_y</span>)
            <span class="pl-s1">optimizier</span>.<span class="pl-c1">zero_grad</span>()
            <span class="pl-s1">loss</span>.<span class="pl-c1">backward</span>()
            <span class="pl-s1">optimizier</span>.<span class="pl-c1">step</span>()
            <span class="pl-c"># if step % 10 == 0 :</span>
        <span class="pl-k">if</span> <span class="pl-s1">verbose</span>:
            <span class="pl-en">print</span>(<span class="pl-s">'epoch:{}/{}'</span>.<span class="pl-c1">format</span>(<span class="pl-s1">epoch</span>,<span class="pl-s1">epoches</span>), <span class="pl-s">'|Loss:'</span>, <span class="pl-s1">loss</span>.<span class="pl-c1">item</span>())
    
    <span class="pl-s1">model</span>.<span class="pl-c1">eval</span>()
    <span class="pl-s1">output</span> <span class="pl-c1">=</span> <span class="pl-en">model</span>(<span class="pl-v">X_train</span>)
    <span class="pl-k">if</span> <span class="pl-s1">thres_criter</span> <span class="pl-c1">==</span> <span class="pl-s">'rmse'</span>:
        <span class="pl-s1">mse_vec</span> <span class="pl-c1">=</span> <span class="pl-en">getMSEvec</span>(<span class="pl-s1">output</span>,<span class="pl-v">X_train</span>)
        <span class="pl-s1">rmse_vec</span> <span class="pl-c1">=</span> <span class="pl-en">se2rmse</span>(<span class="pl-s1">mse_vec</span>).<span class="pl-c1">cpu</span>().<span class="pl-c1">data</span>.<span class="pl-c1">numpy</span>()
        <span class="pl-k">if</span> <span class="pl-s1">verbose</span>:
            <span class="pl-en">print</span>(<span class="pl-s">"max AD score"</span>,<span class="pl-en">max</span>(<span class="pl-s1">rmse_vec</span>))
        <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-en">max</span>(<span class="pl-s1">rmse_vec</span>)
        <span class="pl-s1">rmse_vec</span>.<span class="pl-c1">sort</span>()
        <span class="pl-s1">pctg</span> <span class="pl-c1">=</span> <span class="pl-s1">percentage</span>
        <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">rmse_vec</span>[<span class="pl-en">int</span>(<span class="pl-en">len</span>(<span class="pl-s1">rmse_vec</span>)<span class="pl-c1">*</span><span class="pl-s1">pctg</span>)]
    <span class="pl-k">elif</span> <span class="pl-s1">thres_criter</span> <span class="pl-c1">==</span> <span class="pl-s">'mse'</span>:
        <span class="pl-s1">mse_vec</span> <span class="pl-c1">=</span> <span class="pl-s1">torch</span>.<span class="pl-c1">mean</span>(<span class="pl-en">getMSEvec</span>(<span class="pl-v">X_train</span>, <span class="pl-s1">output</span>), <span class="pl-s1">dim</span><span class="pl-c1">=</span><span class="pl-c1">1</span>).<span class="pl-c1">cpu</span>().<span class="pl-c1">data</span>.<span class="pl-c1">numpy</span>()
        <span class="pl-k">if</span> <span class="pl-s1">verbose</span>:
            <span class="pl-en">print</span>(<span class="pl-s">"max AD score"</span>,<span class="pl-en">max</span>(<span class="pl-s1">mse_vec</span>))
        <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-en">max</span>(<span class="pl-s1">mse_vec</span>)
        <span class="pl-s1">mse_vec</span>.<span class="pl-c1">sort</span>()
        <span class="pl-s1">pctg</span> <span class="pl-c1">=</span> <span class="pl-s1">percentage</span>
        <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">mse_vec</span>[<span class="pl-en">int</span>(<span class="pl-en">len</span>(<span class="pl-s1">mse_vec</span>)<span class="pl-c1">*</span><span class="pl-s1">pctg</span>)]
    <span class="pl-k">else</span>:
        <span class="pl-en">print</span>(<span class="pl-s">'Unknown criterion for selecting threshold'</span>, <span class="pl-s1">thres_criter</span>)
        <span class="pl-en">exit</span>(<span class="pl-c1">-</span><span class="pl-c1">1</span>)
        
    <span class="pl-s1">model</span>.<span class="pl-c1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">thres</span>
    <span class="pl-k">if</span> <span class="pl-s1">verbose</span>:
        <span class="pl-en">print</span>(<span class="pl-s">f"Threshold is: <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">thres</span><span class="pl-kos">}</span></span> (at percentage <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">percentage</span><span class="pl-kos">}</span></span>)"</span> )

    <span class="pl-k">return</span> <span class="pl-s1">model</span>

<span class="pl-c"># use X_valid to decide the best model</span>
<span class="pl-k">def</span> <span class="pl-en">train_valid</span>(<span class="pl-v">X_train</span>, <span class="pl-s1">feature_size</span>, <span class="pl-v">X_valid</span>, <span class="pl-s1">y_valid</span>, 
                <span class="pl-s1">epoches</span><span class="pl-c1">=</span><span class="pl-s1">epoches</span>, <span class="pl-s1">lr</span><span class="pl-c1">=</span><span class="pl-s1">lr</span>, <span class="pl-s1">weight_decay</span><span class="pl-c1">=</span><span class="pl-s1">weight_decay</span>, <span class="pl-s1">batch_size</span><span class="pl-c1">=</span><span class="pl-s1">batch_size</span>, 
                <span class="pl-s1">percentage</span><span class="pl-c1">=</span><span class="pl-c1">0.99</span>, <span class="pl-s1">thres_criter</span><span class="pl-c1">=</span><span class="pl-s">'rmse'</span>, <span class="pl-s1">verbose</span><span class="pl-c1">=</span><span class="pl-c1">True</span>, <span class="pl-s1">debug</span><span class="pl-c1">=</span><span class="pl-c1">False</span>, <span class="pl-s1">opt</span><span class="pl-c1">=</span><span class="pl-s">'Adam'</span>):
    <span class="pl-s1">config</span> <span class="pl-c1">=</span> {
        <span class="pl-s">'epoches'</span>: <span class="pl-s1">epoches</span>,
        <span class="pl-s">'lr'</span>:<span class="pl-s1">lr</span>,
        <span class="pl-s">'percentage'</span>:<span class="pl-s1">percentage</span>,
        <span class="pl-s">'weight_decay'</span>:<span class="pl-s1">weight_decay</span>,
        <span class="pl-s">'device'</span>:<span class="pl-s1">device</span>,
    }
    <span class="pl-k">if</span> <span class="pl-s1">verbose</span>:
        <span class="pl-en">print</span>(<span class="pl-s">"Hyper parameter config:"</span>, <span class="pl-s1">config</span>)
        
    <span class="pl-s1">model</span> <span class="pl-c1">=</span> <span class="pl-en">autoencoder</span>(<span class="pl-s1">feature_size</span>, <span class="pl-s1">thres_criter</span>).<span class="pl-c1">to</span>(<span class="pl-s1">device</span>)
    <span class="pl-k">if</span> <span class="pl-s1">opt</span> <span class="pl-c1">==</span> <span class="pl-s">'Adam'</span>:
        <span class="pl-s1">optimizier</span> <span class="pl-c1">=</span> <span class="pl-s1">optim</span>.<span class="pl-c1">Adam</span>(<span class="pl-s1">model</span>.<span class="pl-c1">parameters</span>(), <span class="pl-s1">lr</span><span class="pl-c1">=</span><span class="pl-s1">lr</span>, <span class="pl-s1">weight_decay</span><span class="pl-c1">=</span><span class="pl-s1">weight_decay</span>)
    <span class="pl-k">elif</span> <span class="pl-s1">opt</span> <span class="pl-c1">==</span> <span class="pl-s">'SGD'</span>:
        <span class="pl-s1">optimizier</span> <span class="pl-c1">=</span> <span class="pl-s1">optim</span>.<span class="pl-c1">SGD</span>(<span class="pl-s1">model</span>.<span class="pl-c1">parameters</span>(), <span class="pl-s1">lr</span><span class="pl-c1">=</span><span class="pl-s1">lr</span>)
    <span class="pl-k">else</span>: 
        <span class="pl-k">raise</span> <span class="pl-en">RuntimeError</span>(<span class="pl-s">f'Unknown optimizier: <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">opt</span><span class="pl-kos">}</span></span>'</span>)

    <span class="pl-v">X_train</span> <span class="pl-c1">=</span> <span class="pl-s1">torch</span>.<span class="pl-c1">from_numpy</span>(<span class="pl-v">X_train</span>).<span class="pl-c1">type</span>(<span class="pl-s1">torch</span>.<span class="pl-c1">float</span>).<span class="pl-c1">to</span>(<span class="pl-s1">device</span>)  
    <span class="pl-s1">torch_dataset</span> <span class="pl-c1">=</span> <span class="pl-v">Data</span>.<span class="pl-c1">TensorDataset</span>(<span class="pl-v">X_train</span>, <span class="pl-v">X_train</span>)
    <span class="pl-s1">loader</span> <span class="pl-c1">=</span> <span class="pl-v">Data</span>.<span class="pl-c1">DataLoader</span>(
        <span class="pl-s1">dataset</span><span class="pl-c1">=</span><span class="pl-s1">torch_dataset</span>,
        <span class="pl-s1">batch_size</span><span class="pl-c1">=</span><span class="pl-s1">batch_size</span>,
        <span class="pl-s1">shuffle</span><span class="pl-c1">=</span><span class="pl-c1">True</span>,
    )
    
    <span class="pl-s1">best_model</span>, <span class="pl-s1">best_auc</span>, <span class="pl-s1">best_thres</span> <span class="pl-c1">=</span>  <span class="pl-c1">None</span>, <span class="pl-c1">-</span><span class="pl-s1">np</span>.<span class="pl-c1">Inf</span>, <span class="pl-c1">None</span>

    <span class="pl-k">for</span> <span class="pl-s1">epoch</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-s1">epoches</span>):
        <span class="pl-s1">model</span>.<span class="pl-c1">train</span>()
        <span class="pl-k">for</span> <span class="pl-s1">step</span>, (<span class="pl-s1">batch_x</span>, <span class="pl-s1">batch_y</span>) <span class="pl-c1">in</span> <span class="pl-en">enumerate</span>(<span class="pl-s1">loader</span>):
            <span class="pl-s1">output</span> <span class="pl-c1">=</span> <span class="pl-en">model</span>(<span class="pl-s1">batch_x</span>)
            <span class="pl-s1">loss</span> <span class="pl-c1">=</span> <span class="pl-en">criterion</span>(<span class="pl-s1">output</span>, <span class="pl-s1">batch_y</span>)
            <span class="pl-s1">optimizier</span>.<span class="pl-c1">zero_grad</span>()
            <span class="pl-s1">loss</span>.<span class="pl-c1">backward</span>()
            <span class="pl-s1">optimizier</span>.<span class="pl-c1">step</span>()
        <span class="pl-k">if</span> <span class="pl-s1">verbose</span>:
            <span class="pl-en">print</span>(<span class="pl-s">'epoch:{}/{}'</span>.<span class="pl-c1">format</span>(<span class="pl-s1">epoch</span>,<span class="pl-s1">epoches</span>), <span class="pl-s">'|Loss:'</span>, <span class="pl-s1">loss</span>.<span class="pl-c1">item</span>())

        <span class="pl-s1">model</span>.<span class="pl-c1">eval</span>()
        <span class="pl-c"># get raw threshold for model </span>
        <span class="pl-s1">output</span> <span class="pl-c1">=</span> <span class="pl-en">model</span>(<span class="pl-v">X_train</span>)
        <span class="pl-k">if</span> <span class="pl-s1">thres_criter</span> <span class="pl-c1">==</span> <span class="pl-s">'rmse'</span>:
            <span class="pl-s1">mse_vec</span> <span class="pl-c1">=</span> <span class="pl-en">getMSEvec</span>(<span class="pl-s1">output</span>,<span class="pl-v">X_train</span>)
            <span class="pl-s1">rmse_vec</span> <span class="pl-c1">=</span> <span class="pl-en">se2rmse</span>(<span class="pl-s1">mse_vec</span>).<span class="pl-c1">cpu</span>().<span class="pl-c1">data</span>.<span class="pl-c1">numpy</span>()
            <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-en">max</span>(<span class="pl-s1">rmse_vec</span>)
            <span class="pl-s1">rmse_vec</span>.<span class="pl-c1">sort</span>()
            <span class="pl-s1">pctg</span> <span class="pl-c1">=</span> <span class="pl-s1">percentage</span>
            <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">rmse_vec</span>[<span class="pl-en">int</span>(<span class="pl-en">len</span>(<span class="pl-s1">rmse_vec</span>)<span class="pl-c1">*</span><span class="pl-s1">pctg</span>)]
        <span class="pl-k">elif</span> <span class="pl-s1">thres_criter</span> <span class="pl-c1">==</span> <span class="pl-s">'mse'</span>:
            <span class="pl-s1">mse_vec</span> <span class="pl-c1">=</span> <span class="pl-s1">torch</span>.<span class="pl-c1">mean</span>(<span class="pl-en">getMSEvec</span>(<span class="pl-v">X_train</span>, <span class="pl-s1">output</span>), <span class="pl-s1">dim</span><span class="pl-c1">=</span><span class="pl-c1">1</span>).<span class="pl-c1">cpu</span>().<span class="pl-c1">data</span>.<span class="pl-c1">numpy</span>()
            <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-en">max</span>(<span class="pl-s1">mse_vec</span>)
            <span class="pl-s1">mse_vec</span>.<span class="pl-c1">sort</span>()
            <span class="pl-s1">pctg</span> <span class="pl-c1">=</span> <span class="pl-s1">percentage</span>
            <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">mse_vec</span>[<span class="pl-en">int</span>(<span class="pl-en">len</span>(<span class="pl-s1">mse_vec</span>)<span class="pl-c1">*</span><span class="pl-s1">pctg</span>)]
        <span class="pl-k">else</span>:
            <span class="pl-en">print</span>(<span class="pl-s">'Unknown criterion for selecting threshold'</span>, <span class="pl-s1">thres_criter</span>)
            <span class="pl-en">exit</span>(<span class="pl-c1">-</span><span class="pl-c1">1</span>)
        <span class="pl-s1">model</span>.<span class="pl-c1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">thres</span>

        <span class="pl-s1">_</span>, <span class="pl-s1">y_valid_rmse</span> <span class="pl-c1">=</span> <span class="pl-en">test</span>(<span class="pl-s1">model</span>, <span class="pl-v">X_valid</span>)
        <span class="pl-s1">roc_auc</span>, <span class="pl-s1">o_thres</span> <span class="pl-c1">=</span> <span class="pl-en">eval_roc</span>(<span class="pl-s1">y_valid_rmse</span>, <span class="pl-s1">y_valid</span>, <span class="pl-s1">thres_max</span><span class="pl-c1">=</span><span class="pl-s1">model</span>.<span class="pl-c1">thres</span><span class="pl-c1">*</span><span class="pl-c1">1.5</span>, <span class="pl-s1">plot</span><span class="pl-c1">=</span><span class="pl-c1">False</span>, <span class="pl-s1">verbose</span><span class="pl-c1">=</span><span class="pl-c1">False</span>)
        <span class="pl-k">if</span> <span class="pl-s1">roc_auc</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">best_auc</span>:
            <span class="pl-s1">best_auc</span> <span class="pl-c1">=</span> <span class="pl-s1">roc_auc</span>
            <span class="pl-s1">best_thres</span> <span class="pl-c1">=</span> <span class="pl-s1">o_thres</span>
            <span class="pl-s1">best_model</span> <span class="pl-c1">=</span> <span class="pl-s1">copy</span>.<span class="pl-c1">deepcopy</span>(<span class="pl-s1">model</span>)
            <span class="pl-s1">model</span>.<span class="pl-c1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">best_thres</span>
            <span class="pl-s1">y_valid_pred</span>, <span class="pl-s1">_</span> <span class="pl-c1">=</span> <span class="pl-en">test</span>(<span class="pl-s1">model</span>, <span class="pl-v">X_valid</span>)
            <span class="pl-s1">tpr</span>, <span class="pl-s1">fpr</span> <span class="pl-c1">=</span> <span class="pl-en">TPR_FPR</span>(<span class="pl-s1">y_valid_pred</span>, <span class="pl-s1">y_valid</span>, <span class="pl-s1">model</span>.<span class="pl-c1">thres</span>, <span class="pl-s1">verbose</span><span class="pl-c1">=</span><span class="pl-c1">False</span>)
            <span class="pl-k">if</span> <span class="pl-s1">verbose</span>: <span class="pl-en">print</span>(<span class="pl-s">f'- update model! valid: roc auc is <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">best_auc</span>:.5f<span class="pl-kos">}</span></span>, tpr: <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">tpr</span>:.5f<span class="pl-kos">}</span></span>, fpr:<span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">fpr</span>:.5f<span class="pl-kos">}</span></span>'</span>)
        <span class="pl-k">elif</span> <span class="pl-s1">debug</span>:
            <span class="pl-s1">y_valid_pred</span>, <span class="pl-s1">_</span> <span class="pl-c1">=</span> <span class="pl-en">test</span>(<span class="pl-s1">model</span>, <span class="pl-v">X_valid</span>)
            <span class="pl-s1">tpr</span>, <span class="pl-s1">fpr</span> <span class="pl-c1">=</span> <span class="pl-en">TPR_FPR</span>(<span class="pl-s1">y_valid_pred</span>, <span class="pl-s1">y_valid</span>, <span class="pl-s1">o_thres</span>, <span class="pl-s1">verbose</span><span class="pl-c1">=</span><span class="pl-c1">False</span>)
            <span class="pl-en">print</span>(<span class="pl-s">f'(- NOT update, valid: roc auc is <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">roc_auc</span>:.5f<span class="pl-kos">}</span></span>, tpr: <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">tpr</span>:.5f<span class="pl-kos">}</span></span>, fpr:<span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">fpr</span>:.5f<span class="pl-kos">}</span></span>)'</span>)

    <span class="pl-k">if</span> <span class="pl-s1">verbose</span>:
        <span class="pl-en">print</span>(<span class="pl-s">f"Threshold is: <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">model</span>.<span class="pl-c1">thres</span><span class="pl-kos">}</span></span> (at percentage <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">percentage</span><span class="pl-kos">}</span></span>)"</span> )

    <span class="pl-k">return</span> <span class="pl-s1">best_model</span>



<span class="pl-k">def</span> <span class="pl-en">train_pos_sampling</span>(<span class="pl-v">X_train_ben</span>, <span class="pl-v">X_train_pos</span>, <span class="pl-s1">feature_size</span>, <span class="pl-s1">pos_weight</span> <span class="pl-c1">=</span> <span class="pl-c1">1.</span>,
                       <span class="pl-s1">epoches</span><span class="pl-c1">=</span><span class="pl-s1">epoches</span>, <span class="pl-s1">lr</span><span class="pl-c1">=</span><span class="pl-s1">lr</span>, <span class="pl-s1">weight_decay</span><span class="pl-c1">=</span><span class="pl-s1">weight_decay</span>, <span class="pl-s1">batch_size</span><span class="pl-c1">=</span><span class="pl-s1">batch_size</span>, 
                       <span class="pl-s1">percentage</span><span class="pl-c1">=</span><span class="pl-c1">0.99</span>, <span class="pl-s1">thres_criter</span><span class="pl-c1">=</span><span class="pl-s">'rmse'</span>, <span class="pl-s1">verbose</span><span class="pl-c1">=</span><span class="pl-c1">True</span>, <span class="pl-s1">debug</span><span class="pl-c1">=</span><span class="pl-c1">False</span>, <span class="pl-s1">opt</span><span class="pl-c1">=</span><span class="pl-s">'Adam'</span>,
                       <span class="pl-v">X_valid</span> <span class="pl-c1">=</span> <span class="pl-c1">None</span>, <span class="pl-s1">y_valid</span> <span class="pl-c1">=</span> <span class="pl-c1">None</span>, <span class="pl-c"># if not None, will use validation set to choose best model</span>
                       ):
    <span class="pl-c"># clip to make sure X_train_pos and X_train_ben is with the same size</span>
    <span class="pl-k">if</span> <span class="pl-en">len</span>(<span class="pl-v">X_train_pos</span>) <span class="pl-c1">&gt;=</span> <span class="pl-en">len</span>(<span class="pl-v">X_train_ben</span>):
        <span class="pl-v">X_train_pos</span> <span class="pl-c1">=</span> <span class="pl-v">X_train_pos</span>[:<span class="pl-en">len</span>(<span class="pl-v">X_train_ben</span>)]
    <span class="pl-k">else</span>:
        <span class="pl-s1">repeats</span> <span class="pl-c1">=</span> <span class="pl-c1">-</span>(<span class="pl-c1">-</span><span class="pl-en">len</span>(<span class="pl-v">X_train_ben</span>)<span class="pl-c1">//</span><span class="pl-en">len</span>(<span class="pl-v">X_train_pos</span>))
        <span class="pl-v">X_train_pos</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">tile</span>(<span class="pl-v">X_train_pos</span>, (<span class="pl-s1">repeats</span>, <span class="pl-c1">1</span>))
        <span class="pl-v">X_train_pos</span> <span class="pl-c1">=</span> <span class="pl-v">X_train_pos</span>[:<span class="pl-en">len</span>(<span class="pl-v">X_train_ben</span>)]

    <span class="pl-s1">config</span> <span class="pl-c1">=</span> {
        <span class="pl-s">'epoches'</span>: <span class="pl-s1">epoches</span>,
        <span class="pl-s">'lr'</span>:<span class="pl-s1">lr</span>,
        <span class="pl-s">'percentage'</span>:<span class="pl-s1">percentage</span>,
        <span class="pl-s">'weight_decay'</span>:<span class="pl-s1">weight_decay</span>,
        <span class="pl-s">'device'</span>:<span class="pl-s1">device</span>,
    }
    <span class="pl-k">if</span> <span class="pl-s1">verbose</span>:
        <span class="pl-en">print</span>(<span class="pl-s">"Hyper parameter config:"</span>, <span class="pl-s1">config</span>)
        
    <span class="pl-s1">model</span> <span class="pl-c1">=</span> <span class="pl-en">autoencoder</span>(<span class="pl-s1">feature_size</span>, <span class="pl-s1">thres_criter</span>).<span class="pl-c1">to</span>(<span class="pl-s1">device</span>)
    <span class="pl-k">if</span> <span class="pl-s1">opt</span> <span class="pl-c1">==</span> <span class="pl-s">'Adam'</span>:
        <span class="pl-s1">optimizier</span> <span class="pl-c1">=</span> <span class="pl-s1">optim</span>.<span class="pl-c1">Adam</span>(<span class="pl-s1">model</span>.<span class="pl-c1">parameters</span>(), <span class="pl-s1">lr</span><span class="pl-c1">=</span><span class="pl-s1">lr</span>, <span class="pl-s1">weight_decay</span><span class="pl-c1">=</span><span class="pl-s1">weight_decay</span>)
    <span class="pl-k">elif</span> <span class="pl-s1">opt</span> <span class="pl-c1">==</span> <span class="pl-s">'SGD'</span>:
        <span class="pl-s1">optimizier</span> <span class="pl-c1">=</span> <span class="pl-s1">optim</span>.<span class="pl-c1">SGD</span>(<span class="pl-s1">model</span>.<span class="pl-c1">parameters</span>(), <span class="pl-s1">lr</span><span class="pl-c1">=</span><span class="pl-s1">lr</span>)
    <span class="pl-k">else</span>: 
        <span class="pl-k">raise</span> <span class="pl-en">RuntimeError</span>(<span class="pl-s">f'Unknown optimizier: <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">opt</span><span class="pl-kos">}</span></span>'</span>)

    <span class="pl-v">X_train_ben</span> <span class="pl-c1">=</span> <span class="pl-s1">torch</span>.<span class="pl-c1">from_numpy</span>(<span class="pl-v">X_train_ben</span>).<span class="pl-c1">type</span>(<span class="pl-s1">torch</span>.<span class="pl-c1">float</span>).<span class="pl-c1">to</span>(<span class="pl-s1">device</span>)
    <span class="pl-v">X_train_pos</span> <span class="pl-c1">=</span> <span class="pl-s1">torch</span>.<span class="pl-c1">from_numpy</span>(<span class="pl-v">X_train_pos</span>).<span class="pl-c1">type</span>(<span class="pl-s1">torch</span>.<span class="pl-c1">float</span>).<span class="pl-c1">to</span>(<span class="pl-s1">device</span>)

    <span class="pl-s1">torch_dataset</span> <span class="pl-c1">=</span> <span class="pl-v">Data</span>.<span class="pl-c1">TensorDataset</span>(<span class="pl-v">X_train_ben</span>, <span class="pl-v">X_train_pos</span>)
    <span class="pl-s1">loader</span> <span class="pl-c1">=</span> <span class="pl-v">Data</span>.<span class="pl-c1">DataLoader</span>(
        <span class="pl-s1">dataset</span><span class="pl-c1">=</span><span class="pl-s1">torch_dataset</span>,
        <span class="pl-s1">batch_size</span><span class="pl-c1">=</span><span class="pl-s1">batch_size</span>,
        <span class="pl-s1">shuffle</span><span class="pl-c1">=</span><span class="pl-c1">True</span>,
    )
    
    <span class="pl-s1">best_model</span>, <span class="pl-s1">best_auc</span>, <span class="pl-s1">best_thres</span> <span class="pl-c1">=</span>  <span class="pl-c1">None</span>, <span class="pl-c1">-</span><span class="pl-s1">np</span>.<span class="pl-c1">Inf</span>, <span class="pl-c1">None</span>
    <span class="pl-v">Bound</span> <span class="pl-c1">=</span> <span class="pl-s1">nn</span>.<span class="pl-c1">ReLU</span>()
    <span class="pl-c1">MAX_THRES</span> <span class="pl-c1">=</span> <span class="pl-c1">4.</span>
    
    <span class="pl-k">for</span> <span class="pl-s1">epoch</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-s1">epoches</span>):
        <span class="pl-s1">model</span>.<span class="pl-c1">train</span>()
        <span class="pl-k">for</span> <span class="pl-s1">step</span>, (<span class="pl-s1">batch_x_neg</span>, <span class="pl-s1">batch_x_pos</span>) <span class="pl-c1">in</span> <span class="pl-en">enumerate</span>(<span class="pl-s1">loader</span>):
            <span class="pl-s1">output_neg</span> <span class="pl-c1">=</span> <span class="pl-en">model</span>(<span class="pl-s1">batch_x_neg</span>)
            <span class="pl-s1">loss_neg</span> <span class="pl-c1">=</span> <span class="pl-en">criterion</span>(<span class="pl-s1">output_neg</span>, <span class="pl-s1">batch_x_neg</span>)
            <span class="pl-s1">output_pos</span> <span class="pl-c1">=</span> <span class="pl-en">model</span>(<span class="pl-s1">batch_x_pos</span>)
            <span class="pl-s1">loss_pos</span> <span class="pl-c1">=</span> <span class="pl-en">Bound</span>(<span class="pl-c1">MAX_THRES</span><span class="pl-c1">-</span><span class="pl-en">criterion</span>(<span class="pl-s1">output_pos</span>, <span class="pl-s1">batch_x_pos</span>))
            <span class="pl-s1">loss</span> <span class="pl-c1">=</span> <span class="pl-s1">loss_neg</span> <span class="pl-c1">+</span> <span class="pl-s1">pos_weight</span> <span class="pl-c1">*</span> <span class="pl-s1">loss_pos</span>
            <span class="pl-s1">optimizier</span>.<span class="pl-c1">zero_grad</span>()
            <span class="pl-s1">loss</span>.<span class="pl-c1">backward</span>()
            <span class="pl-s1">optimizier</span>.<span class="pl-c1">step</span>()

        <span class="pl-k">if</span> <span class="pl-s1">verbose</span>:
            <span class="pl-en">print</span>(<span class="pl-s">'epoch:{}/{}'</span>.<span class="pl-c1">format</span>(<span class="pl-s1">epoch</span>,<span class="pl-s1">epoches</span>), <span class="pl-s">'|Loss:'</span>, <span class="pl-s1">loss</span>.<span class="pl-c1">item</span>(), <span class="pl-s">f'(neg: <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">loss_neg</span>.<span class="pl-c1">item</span>()<span class="pl-kos">}</span></span>, pos:<span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">loss_pos</span>.<span class="pl-c1">item</span>()<span class="pl-kos">}</span></span>)'</span>)

        <span class="pl-k">if</span> (<span class="pl-v">X_valid</span> <span class="pl-c1"><span class="pl-c1">is</span> <span class="pl-c1">not</span></span> <span class="pl-c1">None</span> <span class="pl-c1">and</span> <span class="pl-s1">y_valid</span> <span class="pl-c1"><span class="pl-c1">is</span> <span class="pl-c1">not</span></span> <span class="pl-c1">None</span>) <span class="pl-c1">or</span> (<span class="pl-s1">epoch</span> <span class="pl-c1">==</span> <span class="pl-s1">epoches</span><span class="pl-c1">-</span><span class="pl-c1">1</span>):
            <span class="pl-s1">model</span>.<span class="pl-c1">eval</span>()
            <span class="pl-c"># get raw threshold for model </span>
            <span class="pl-s1">output</span> <span class="pl-c1">=</span> <span class="pl-en">model</span>(<span class="pl-v">X_train_ben</span>)
            <span class="pl-k">if</span> <span class="pl-s1">thres_criter</span> <span class="pl-c1">==</span> <span class="pl-s">'rmse'</span>:
                <span class="pl-s1">mse_vec</span> <span class="pl-c1">=</span> <span class="pl-en">getMSEvec</span>(<span class="pl-s1">output</span>,<span class="pl-v">X_train_ben</span>)
                <span class="pl-s1">rmse_vec</span> <span class="pl-c1">=</span> <span class="pl-en">se2rmse</span>(<span class="pl-s1">mse_vec</span>).<span class="pl-c1">cpu</span>().<span class="pl-c1">data</span>.<span class="pl-c1">numpy</span>()
                <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-en">max</span>(<span class="pl-s1">rmse_vec</span>)
                <span class="pl-s1">rmse_vec</span>.<span class="pl-c1">sort</span>()
                <span class="pl-s1">pctg</span> <span class="pl-c1">=</span> <span class="pl-s1">percentage</span>
                <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">rmse_vec</span>[<span class="pl-en">int</span>(<span class="pl-en">len</span>(<span class="pl-s1">rmse_vec</span>)<span class="pl-c1">*</span><span class="pl-s1">pctg</span>)]
            <span class="pl-k">elif</span> <span class="pl-s1">thres_criter</span> <span class="pl-c1">==</span> <span class="pl-s">'mse'</span>:
                <span class="pl-s1">mse_vec</span> <span class="pl-c1">=</span> <span class="pl-s1">torch</span>.<span class="pl-c1">mean</span>(<span class="pl-en">getMSEvec</span>(<span class="pl-v">X_train_ben</span>, <span class="pl-s1">output</span>), <span class="pl-s1">dim</span><span class="pl-c1">=</span><span class="pl-c1">1</span>).<span class="pl-c1">cpu</span>().<span class="pl-c1">data</span>.<span class="pl-c1">numpy</span>()
                <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-en">max</span>(<span class="pl-s1">mse_vec</span>)
                <span class="pl-s1">mse_vec</span>.<span class="pl-c1">sort</span>()
                <span class="pl-s1">pctg</span> <span class="pl-c1">=</span> <span class="pl-s1">percentage</span>
                <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">mse_vec</span>[<span class="pl-en">int</span>(<span class="pl-en">len</span>(<span class="pl-s1">mse_vec</span>)<span class="pl-c1">*</span><span class="pl-s1">pctg</span>)]
            <span class="pl-k">else</span>:
                <span class="pl-en">print</span>(<span class="pl-s">'Unknown criterion for selecting threshold'</span>, <span class="pl-s1">thres_criter</span>)
                <span class="pl-en">exit</span>(<span class="pl-c1">-</span><span class="pl-c1">1</span>)
            <span class="pl-s1">model</span>.<span class="pl-c1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">thres</span>

        <span class="pl-k">if</span> <span class="pl-v">X_valid</span> <span class="pl-c1"><span class="pl-c1">is</span> <span class="pl-c1">not</span></span> <span class="pl-c1">None</span> <span class="pl-c1">and</span> <span class="pl-s1">y_valid</span> <span class="pl-c1"><span class="pl-c1">is</span> <span class="pl-c1">not</span></span> <span class="pl-c1">None</span>:
            <span class="pl-s1">_</span>, <span class="pl-s1">y_valid_rmse</span> <span class="pl-c1">=</span> <span class="pl-en">test</span>(<span class="pl-s1">model</span>, <span class="pl-v">X_valid</span>)
            <span class="pl-s1">roc_auc</span>, <span class="pl-s1">o_thres</span> <span class="pl-c1">=</span> <span class="pl-en">eval_roc</span>(<span class="pl-s1">y_valid_rmse</span>, <span class="pl-s1">y_valid</span>, <span class="pl-s1">thres_max</span><span class="pl-c1">=</span><span class="pl-s1">model</span>.<span class="pl-c1">thres</span><span class="pl-c1">*</span><span class="pl-c1">1.5</span>, <span class="pl-s1">plot</span><span class="pl-c1">=</span><span class="pl-c1">False</span>, <span class="pl-s1">verbose</span><span class="pl-c1">=</span><span class="pl-c1">False</span>)
            <span class="pl-k">if</span> <span class="pl-s1">roc_auc</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">best_auc</span>:
                <span class="pl-s1">best_auc</span> <span class="pl-c1">=</span> <span class="pl-s1">roc_auc</span>
                <span class="pl-s1">best_thres</span> <span class="pl-c1">=</span> <span class="pl-s1">o_thres</span>
                <span class="pl-s1">best_model</span> <span class="pl-c1">=</span> <span class="pl-s1">copy</span>.<span class="pl-c1">deepcopy</span>(<span class="pl-s1">model</span>)
                <span class="pl-s1">model</span>.<span class="pl-c1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">best_thres</span>
                <span class="pl-s1">y_valid_pred</span>, <span class="pl-s1">_</span> <span class="pl-c1">=</span> <span class="pl-en">test</span>(<span class="pl-s1">model</span>, <span class="pl-v">X_valid</span>)
                <span class="pl-s1">tpr</span>, <span class="pl-s1">fpr</span> <span class="pl-c1">=</span> <span class="pl-en">TPR_FPR</span>(<span class="pl-s1">y_valid_pred</span>, <span class="pl-s1">y_valid</span>, <span class="pl-s1">model</span>.<span class="pl-c1">thres</span>, <span class="pl-s1">verbose</span><span class="pl-c1">=</span><span class="pl-c1">False</span>)
                <span class="pl-k">if</span> <span class="pl-s1">verbose</span>: <span class="pl-en">print</span>(<span class="pl-s">f'- update model! valid: roc auc is <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">best_auc</span>:.5f<span class="pl-kos">}</span></span>, tpr: <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">tpr</span>:.5f<span class="pl-kos">}</span></span>, fpr:<span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">fpr</span>:.5f<span class="pl-kos">}</span></span>'</span>)
            <span class="pl-k">elif</span> <span class="pl-s1">debug</span>:
                <span class="pl-s1">y_valid_pred</span>, <span class="pl-s1">_</span> <span class="pl-c1">=</span> <span class="pl-en">test</span>(<span class="pl-s1">model</span>, <span class="pl-v">X_valid</span>)
                <span class="pl-s1">tpr</span>, <span class="pl-s1">fpr</span> <span class="pl-c1">=</span> <span class="pl-en">TPR_FPR</span>(<span class="pl-s1">y_valid_pred</span>, <span class="pl-s1">y_valid</span>, <span class="pl-s1">o_thres</span>, <span class="pl-s1">verbose</span><span class="pl-c1">=</span><span class="pl-c1">False</span>)
                <span class="pl-en">print</span>(<span class="pl-s">f'(- NOT update, valid: roc auc is <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">roc_auc</span>:.5f<span class="pl-kos">}</span></span>, tpr: <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">tpr</span>:.5f<span class="pl-kos">}</span></span>, fpr:<span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">fpr</span>:.5f<span class="pl-kos">}</span></span>)'</span>)
        <span class="pl-k">else</span>:
            <span class="pl-s1">best_model</span> <span class="pl-c1">=</span> <span class="pl-s1">model</span>

    <span class="pl-k">if</span> <span class="pl-s1">verbose</span>:
        <span class="pl-en">print</span>(<span class="pl-s">f"Threshold is: <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">model</span>.<span class="pl-c1">thres</span><span class="pl-kos">}</span></span> (at percentage <span class="pl-s1"><span class="pl-kos">{</span><span class="pl-s1">percentage</span><span class="pl-kos">}</span></span>)"</span> )

    <span class="pl-k">return</span> <span class="pl-s1">best_model</span>


<span class="pl-en">@<span class="pl-s1">torch</span>.<span class="pl-c1">no_grad</span>()</span>
<span class="pl-k">def</span> <span class="pl-en">test</span>(<span class="pl-s1">model</span>, <span class="pl-v">X_test</span>, <span class="pl-s1">thres</span><span class="pl-c1">=</span><span class="pl-c1">None</span>):
    <span class="pl-k">if</span> <span class="pl-s1">thres</span> <span class="pl-c1">is</span> <span class="pl-c1">None</span>:
        <span class="pl-s1">thres</span> <span class="pl-c1">=</span> <span class="pl-s1">model</span>.<span class="pl-c1">thres</span> 
    <span class="pl-s1">model</span>.<span class="pl-c1">eval</span>()
    <span class="pl-v">X_test</span> <span class="pl-c1">=</span> <span class="pl-s1">torch</span>.<span class="pl-c1">from_numpy</span>(<span class="pl-v">X_test</span>).<span class="pl-c1">type</span>(<span class="pl-s1">torch</span>.<span class="pl-c1">float</span>)    
    <span class="pl-v">X_test</span> <span class="pl-c1">=</span> <span class="pl-v">X_test</span>.<span class="pl-c1">to</span>(<span class="pl-s1">device</span>)
    <span class="pl-s1">output</span> <span class="pl-c1">=</span> <span class="pl-en">model</span>(<span class="pl-v">X_test</span>)
    <span class="pl-k">if</span> <span class="pl-s1">model</span>.<span class="pl-c1">criter</span> <span class="pl-c1">==</span> <span class="pl-s">'rmse'</span>:
        <span class="pl-s1">mse_vec</span> <span class="pl-c1">=</span> <span class="pl-en">getMSEvec</span>(<span class="pl-s1">output</span>,<span class="pl-v">X_test</span>)
        <span class="pl-s1">rmse_vec</span> <span class="pl-c1">=</span> <span class="pl-en">se2rmse</span>(<span class="pl-s1">mse_vec</span>).<span class="pl-c1">cpu</span>().<span class="pl-c1">data</span>.<span class="pl-c1">numpy</span>()
        <span class="pl-s1">idx_mal</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">where</span>(<span class="pl-s1">rmse_vec</span><span class="pl-c1">&gt;</span><span class="pl-s1">thres</span>)
        <span class="pl-s1">ano_score</span> <span class="pl-c1">=</span> <span class="pl-s1">rmse_vec</span>
    <span class="pl-k">elif</span> <span class="pl-s1">model</span>.<span class="pl-c1">criter</span> <span class="pl-c1">==</span> <span class="pl-s">'mse'</span>:
        <span class="pl-s1">mse_vec</span> <span class="pl-c1">=</span> <span class="pl-s1">torch</span>.<span class="pl-c1">mean</span>(<span class="pl-en">getMSEvec</span>(<span class="pl-v">X_test</span>, <span class="pl-s1">output</span>), <span class="pl-s1">dim</span><span class="pl-c1">=</span><span class="pl-c1">1</span>).<span class="pl-c1">cpu</span>().<span class="pl-c1">data</span>.<span class="pl-c1">numpy</span>()
        <span class="pl-s1">idx_mal</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">where</span>(<span class="pl-s1">mse_vec</span><span class="pl-c1">&gt;</span><span class="pl-s1">thres</span>)
        <span class="pl-s1">ano_score</span> <span class="pl-c1">=</span> <span class="pl-s1">mse_vec</span>
    <span class="pl-k">else</span>:
        <span class="pl-k">raise</span> <span class="pl-v">NotImplementedError</span>
    
     
    <span class="pl-s1">y_pred</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">asarray</span>([<span class="pl-c1">0</span>] <span class="pl-c1">*</span> <span class="pl-en">len</span>(<span class="pl-s1">ano_score</span>))
    <span class="pl-s1">y_pred</span>[<span class="pl-s1">idx_mal</span>] <span class="pl-c1">=</span> <span class="pl-c1">1</span>

    <span class="pl-k">return</span> <span class="pl-s1">y_pred</span>, <span class="pl-s1">ano_score</span>


<span class="pl-k">def</span> <span class="pl-en">test_plot</span>(<span class="pl-s1">rmse_vec</span>, <span class="pl-s1">thres</span>, <span class="pl-s1">file_name</span> <span class="pl-c1">=</span> <span class="pl-c1">None</span>, <span class="pl-s1">label</span> <span class="pl-c1">=</span> <span class="pl-c1">None</span>):
    <span class="pl-s1">plt</span>.<span class="pl-c1">figure</span>()
    <span class="pl-s1">plt</span>.<span class="pl-c1">plot</span>(<span class="pl-s1">np</span>.<span class="pl-c1">linspace</span>(<span class="pl-c1">0</span>,<span class="pl-en">len</span>(<span class="pl-s1">rmse_vec</span>)<span class="pl-c1">-</span><span class="pl-c1">1</span>,<span class="pl-en">len</span>(<span class="pl-s1">rmse_vec</span>)),[<span class="pl-s1">thres</span>]<span class="pl-c1">*</span><span class="pl-en">len</span>(<span class="pl-s1">rmse_vec</span>),<span class="pl-s1">c</span><span class="pl-c1">=</span><span class="pl-s">'black'</span>,<span class="pl-s1">label</span><span class="pl-c1">=</span><span class="pl-s">'99th-threshold'</span>)
    <span class="pl-c"># plt.ylim(0,thres*2.)</span>

    <span class="pl-k">if</span> <span class="pl-s1">label</span> <span class="pl-c1"><span class="pl-c1">is</span> <span class="pl-c1">not</span></span> <span class="pl-c1">None</span>:
        <span class="pl-s1">idx</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">where</span>(<span class="pl-s1">label</span><span class="pl-c1">==</span><span class="pl-c1">0</span>)[<span class="pl-c1">0</span>]
        <span class="pl-s1">plt</span>.<span class="pl-c1">scatter</span>(<span class="pl-s1">idx</span>, <span class="pl-s1">rmse_vec</span>[<span class="pl-s1">idx</span>], <span class="pl-s1">s</span><span class="pl-c1">=</span><span class="pl-c1">8</span>, <span class="pl-s1">color</span><span class="pl-c1">=</span><span class="pl-s">'blue'</span>, <span class="pl-s1">alpha</span><span class="pl-c1">=</span><span class="pl-c1">0.4</span>, <span class="pl-s1">label</span><span class="pl-c1">=</span><span class="pl-s">'Normal'</span>)
        
        <span class="pl-s1">idx</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">where</span>(<span class="pl-s1">label</span><span class="pl-c1">==</span><span class="pl-c1">1</span>)[<span class="pl-c1">0</span>]
        <span class="pl-s1">plt</span>.<span class="pl-c1">scatter</span>(<span class="pl-s1">idx</span>, <span class="pl-s1">rmse_vec</span>[<span class="pl-s1">idx</span>], <span class="pl-s1">s</span><span class="pl-c1">=</span><span class="pl-c1">8</span>, <span class="pl-s1">color</span><span class="pl-c1">=</span><span class="pl-s">'red'</span>, <span class="pl-s1">alpha</span><span class="pl-c1">=</span><span class="pl-c1">0.7</span>, <span class="pl-s1">label</span><span class="pl-c1">=</span><span class="pl-s">'Anomalies'</span>)
    <span class="pl-k">else</span>:
        <span class="pl-s1">plt</span>.<span class="pl-c1">scatter</span>(<span class="pl-s1">np</span>.<span class="pl-c1">linspace</span>(<span class="pl-c1">0</span>,<span class="pl-en">len</span>(<span class="pl-s1">rmse_vec</span>)<span class="pl-c1">-</span><span class="pl-c1">1</span>,<span class="pl-en">len</span>(<span class="pl-s1">rmse_vec</span>)),<span class="pl-s1">rmse_vec</span>,<span class="pl-s1">s</span><span class="pl-c1">=</span><span class="pl-c1">8</span>,<span class="pl-s1">alpha</span><span class="pl-c1">=</span><span class="pl-c1">0.4</span>, <span class="pl-s1">label</span><span class="pl-c1">=</span><span class="pl-s">'Test samples'</span> )
    
    <span class="pl-s1">plt</span>.<span class="pl-c1">legend</span>()
    <span class="pl-s1">plt</span>.<span class="pl-c1">xlabel</span>(<span class="pl-s">'Sample NO.'</span>)
    <span class="pl-s1">plt</span>.<span class="pl-c1">ylabel</span>(<span class="pl-s">'Anomaly Score (RMSE)'</span>)
    <span class="pl-s1">plt</span>.<span class="pl-c1">title</span>(<span class="pl-s">'Per-sample Score'</span>)
    <span class="pl-k">if</span> <span class="pl-s1">file_name</span> <span class="pl-c1">is</span> <span class="pl-c1">None</span>:
        <span class="pl-s1">plt</span>.<span class="pl-c1">show</span>()
    <span class="pl-k">else</span>:
        <span class="pl-s1">plt</span>.<span class="pl-c1">rcParams</span>.<span class="pl-c1">update</span>({<span class="pl-s">'figure.dpi'</span>:<span class="pl-c1">300</span>})
        <span class="pl-s1">plt</span>.<span class="pl-c1">savefig</span>(<span class="pl-s1">file_name</span>)



<span class="pl-k">def</span> <span class="pl-en">TPR_FPR</span>(<span class="pl-s1">y_prob</span>, <span class="pl-s1">y_true</span>, <span class="pl-s1">thres</span>, <span class="pl-s1">verbose</span><span class="pl-c1">=</span><span class="pl-c1">True</span>): 
    <span class="pl-s1">y_true</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">asarray</span>(<span class="pl-s1">y_true</span>)
    <span class="pl-s1">y_prob</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">asarray</span>(<span class="pl-s1">y_prob</span>)
    <span class="pl-s1">y_pred</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">where</span>(<span class="pl-s1">y_prob</span> <span class="pl-c1">&gt;=</span> <span class="pl-s1">thres</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>)

    <span class="pl-s1">fp</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">sum</span>((<span class="pl-s1">y_pred</span> <span class="pl-c1">==</span> <span class="pl-c1">1</span>) <span class="pl-c1">&amp;</span> (<span class="pl-s1">y_true</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>))
    <span class="pl-s1">tp</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">sum</span>((<span class="pl-s1">y_pred</span> <span class="pl-c1">==</span> <span class="pl-c1">1</span>) <span class="pl-c1">&amp;</span> (<span class="pl-s1">y_true</span> <span class="pl-c1">==</span> <span class="pl-c1">1</span>))
    <span class="pl-s1">fn</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">sum</span>((<span class="pl-s1">y_pred</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>) <span class="pl-c1">&amp;</span> (<span class="pl-s1">y_true</span> <span class="pl-c1">==</span> <span class="pl-c1">1</span>))
    <span class="pl-s1">tn</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">sum</span>((<span class="pl-s1">y_pred</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>) <span class="pl-c1">&amp;</span> (<span class="pl-s1">y_true</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>))

    <span class="pl-s1">fpr</span> <span class="pl-c1">=</span> (<span class="pl-s1">fp</span> <span class="pl-c1">/</span> (<span class="pl-s1">fp</span> <span class="pl-c1">+</span> <span class="pl-s1">tn</span> <span class="pl-c1">+</span> <span class="pl-c1">1e-10</span>))
    <span class="pl-s1">tpr</span> <span class="pl-c1">=</span> (<span class="pl-s1">tp</span> <span class="pl-c1">/</span> (<span class="pl-s1">tp</span> <span class="pl-c1">+</span> <span class="pl-s1">fn</span> <span class="pl-c1">+</span> <span class="pl-c1">1e-10</span>))
    
    <span class="pl-k">if</span> <span class="pl-s1">verbose</span>:
        <span class="pl-en">print</span>(<span class="pl-s">'TPR:'</span>, <span class="pl-s1">tpr</span>, <span class="pl-s">'FPR:'</span>, <span class="pl-s1">fpr</span>,)
        <span class="pl-en">print</span>(<span class="pl-s">'TN:'</span>, <span class="pl-s1">tn</span>, <span class="pl-s">'TP:'</span>, <span class="pl-s1">tp</span>, <span class="pl-s">'FP:'</span>, <span class="pl-s1">fp</span>, <span class="pl-s">'FN:'</span>, <span class="pl-s1">fn</span>)
        
    <span class="pl-k">return</span> <span class="pl-s1">tpr</span>, <span class="pl-s1">fpr</span>


<span class="pl-k">def</span> <span class="pl-en">multi_fpr_tpr</span>(<span class="pl-s1">y_prob</span>, <span class="pl-s1">y_true</span>, <span class="pl-s1">thres_max</span>, <span class="pl-s1">thres_min</span><span class="pl-c1">=</span><span class="pl-c1">0</span>, <span class="pl-s1">split</span> <span class="pl-c1">=</span> <span class="pl-c1">300</span>, <span class="pl-s1">is_P_mal</span><span class="pl-c1">=</span><span class="pl-c1">True</span>): 
    <span class="pl-s1">y_true</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">asarray</span>(<span class="pl-s1">y_true</span>)
    <span class="pl-s1">y_prob</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">asarray</span>(<span class="pl-s1">y_prob</span>)
    <span class="pl-s1">fpr</span> <span class="pl-c1">=</span> []
    <span class="pl-s1">tpr</span> <span class="pl-c1">=</span> []

    <span class="pl-s1">thresholds</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">linspace</span>(<span class="pl-s1">thres_min</span>, <span class="pl-s1">thres_max</span>, <span class="pl-s1">split</span>)
    <span class="pl-k">for</span> <span class="pl-s1">threshold</span> <span class="pl-c1">in</span> <span class="pl-s1">thresholds</span>:
        <span class="pl-k">if</span> <span class="pl-s1">is_P_mal</span>: 
            <span class="pl-s1">y_pred</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">where</span>(<span class="pl-s1">y_prob</span> <span class="pl-c1">&gt;=</span> <span class="pl-s1">threshold</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>)
        <span class="pl-k">else</span>:
            <span class="pl-s1">y_pred</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">where</span>(<span class="pl-s1">y_prob</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">threshold</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>)

        <span class="pl-s1">fp</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">sum</span>((<span class="pl-s1">y_pred</span> <span class="pl-c1">==</span> <span class="pl-c1">1</span>) <span class="pl-c1">&amp;</span> (<span class="pl-s1">y_true</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>))
        <span class="pl-s1">tp</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">sum</span>((<span class="pl-s1">y_pred</span> <span class="pl-c1">==</span> <span class="pl-c1">1</span>) <span class="pl-c1">&amp;</span> (<span class="pl-s1">y_true</span> <span class="pl-c1">==</span> <span class="pl-c1">1</span>))

        <span class="pl-s1">fn</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">sum</span>((<span class="pl-s1">y_pred</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>) <span class="pl-c1">&amp;</span> (<span class="pl-s1">y_true</span> <span class="pl-c1">==</span> <span class="pl-c1">1</span>))
        <span class="pl-s1">tn</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">sum</span>((<span class="pl-s1">y_pred</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>) <span class="pl-c1">&amp;</span> (<span class="pl-s1">y_true</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>))

        <span class="pl-c"># print('fp+tn', fp+tn, 'tp + fn', tp + fn)</span>
        <span class="pl-s1">fpr</span>.<span class="pl-c1">append</span>(<span class="pl-s1">fp</span> <span class="pl-c1">/</span> (<span class="pl-s1">fp</span> <span class="pl-c1">+</span> <span class="pl-s1">tn</span>))
        <span class="pl-s1">tpr</span>.<span class="pl-c1">append</span>(<span class="pl-s1">tp</span> <span class="pl-c1">/</span> (<span class="pl-s1">tp</span> <span class="pl-c1">+</span> <span class="pl-s1">fn</span>))

    <span class="pl-k">return</span> <span class="pl-s1">fpr</span>, <span class="pl-s1">tpr</span>, <span class="pl-s1">thresholds</span>

<span class="pl-k">def</span> <span class="pl-en">eval_roc</span>(<span class="pl-s1">probs</span>, <span class="pl-s1">labels</span>, <span class="pl-s1">thres_max</span>, <span class="pl-s1">thres_min</span><span class="pl-c1">=</span><span class="pl-c1">0</span>, <span class="pl-s1">split</span><span class="pl-c1">=</span><span class="pl-c1">300</span>, <span class="pl-s1">is_P_mal</span><span class="pl-c1">=</span><span class="pl-c1">True</span>, <span class="pl-s1">plot</span><span class="pl-c1">=</span><span class="pl-c1">True</span>, <span class="pl-s1">verbose</span><span class="pl-c1">=</span><span class="pl-c1">True</span>):
    <span class="pl-s1">fprs</span>, <span class="pl-s1">tprs</span>, <span class="pl-s1">thresholds</span> <span class="pl-c1">=</span> <span class="pl-en">multi_fpr_tpr</span>(<span class="pl-s1">probs</span>, <span class="pl-s1">labels</span>, <span class="pl-s1">thres_max</span>, <span class="pl-s1">thres_min</span><span class="pl-c1">=</span><span class="pl-s1">thres_min</span>, <span class="pl-s1">split</span><span class="pl-c1">=</span><span class="pl-s1">split</span>, <span class="pl-s1">is_P_mal</span><span class="pl-c1">=</span><span class="pl-s1">is_P_mal</span>)
    <span class="pl-s1">roc_auc</span> <span class="pl-c1">=</span> <span class="pl-s1">metrics</span>.<span class="pl-c1">auc</span>(<span class="pl-s1">fprs</span>, <span class="pl-s1">tprs</span>)
    <span class="pl-k">if</span> <span class="pl-s1">verbose</span>: <span class="pl-en">print</span>(<span class="pl-s">'roc_auc:'</span>,<span class="pl-s1">roc_auc</span>)
    
    <span class="pl-k">if</span> <span class="pl-s1">plot</span>:
        <span class="pl-s1">plt</span>.<span class="pl-c1">figure</span>()
        <span class="pl-s1">plt</span>.<span class="pl-c1">title</span>(<span class="pl-s">'Receiver Operating Characteristic'</span>)
        <span class="pl-s1">plt</span>.<span class="pl-c1">plot</span>(<span class="pl-s1">fprs</span>, <span class="pl-s1">tprs</span>, <span class="pl-s">'b'</span>, <span class="pl-s1">label</span> <span class="pl-c1">=</span> <span class="pl-s">'AUC = %0.2f'</span> <span class="pl-c1">%</span> <span class="pl-s1">roc_auc</span>)
        <span class="pl-s1">plt</span>.<span class="pl-c1">legend</span>(<span class="pl-s1">loc</span> <span class="pl-c1">=</span> <span class="pl-s">'lower right'</span>)
        <span class="pl-s1">plt</span>.<span class="pl-c1">xlim</span>([<span class="pl-c1">0</span>, <span class="pl-c1">1</span>])
        <span class="pl-s1">plt</span>.<span class="pl-c1">ylim</span>([<span class="pl-c1">0</span>, <span class="pl-c1">1</span>])
        <span class="pl-s1">plt</span>.<span class="pl-c1">ylabel</span>(<span class="pl-s">'True Positive Rate'</span>)
        <span class="pl-s1">plt</span>.<span class="pl-c1">xlabel</span>(<span class="pl-s">'False Positive Rate'</span>)
        <span class="pl-s1">plt</span>.<span class="pl-c1">show</span>()
    
    <span class="pl-s1">optimal_idx</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">argmax</span>(<span class="pl-s1">np</span>.<span class="pl-c1">asarray</span>(<span class="pl-s1">tprs</span>) <span class="pl-c1">-</span> <span class="pl-s1">np</span>.<span class="pl-c1">asarray</span>(<span class="pl-s1">fprs</span>))
    <span class="pl-s1">optimal_threshold</span> <span class="pl-c1">=</span> <span class="pl-s1">thresholds</span>[<span class="pl-s1">optimal_idx</span>]
    <span class="pl-k">return</span> <span class="pl-s1">roc_auc</span>, <span class="pl-s1">optimal_threshold</span>

<span class="pl-k">class</span> <span class="pl-v">Normalizer</span>:
    <span class="pl-k">def</span> <span class="pl-en">__init__</span>(<span class="pl-s1">self</span>, <span class="pl-s1">train_data</span>, <span class="pl-s1">clip</span><span class="pl-c1">=</span><span class="pl-c1">False</span>, <span class="pl-s1">delta</span><span class="pl-c1">=</span><span class="pl-c1">1e-10</span>):
        <span class="pl-s1">self</span>.<span class="pl-c1">train_min</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">min</span>(<span class="pl-s1">train_data</span>, <span class="pl-s1">axis</span><span class="pl-c1">=</span><span class="pl-c1">0</span>)
        <span class="pl-s1">self</span>.<span class="pl-c1">train_max</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">max</span>(<span class="pl-s1">train_data</span>, <span class="pl-s1">axis</span><span class="pl-c1">=</span><span class="pl-c1">0</span>)
        <span class="pl-s1">self</span>.<span class="pl-c1">clip</span> <span class="pl-c1">=</span> <span class="pl-s1">clip</span>
        <span class="pl-s1">self</span>.<span class="pl-c1">delta</span> <span class="pl-c1">=</span> <span class="pl-s1">delta</span>

    <span class="pl-k">def</span> <span class="pl-en">transform</span>(<span class="pl-s1">self</span>, <span class="pl-s1">data</span>):
        <span class="pl-k">return</span> (<span class="pl-s1">data</span> <span class="pl-c1">-</span> <span class="pl-s1">self</span>.<span class="pl-c1">train_min</span>) <span class="pl-c1">/</span> (<span class="pl-s1">self</span>.<span class="pl-c1">train_max</span> <span class="pl-c1">-</span> <span class="pl-s1">self</span>.<span class="pl-c1">train_min</span> <span class="pl-c1">+</span> <span class="pl-s1">self</span>.<span class="pl-c1">delta</span>)

    <span class="pl-k">def</span> <span class="pl-en">denorm</span>(<span class="pl-s1">self</span>, <span class="pl-s1">data</span>):
        <span class="pl-k">return</span> <span class="pl-s1">data</span> <span class="pl-c1">*</span> (<span class="pl-s1">self</span>.<span class="pl-c1">train_max</span> <span class="pl-c1">-</span> <span class="pl-s1">self</span>.<span class="pl-c1">train_min</span>) <span class="pl-c1">+</span> <span class="pl-s1">self</span>.<span class="pl-c1">train_min</span>

    <span class="pl-k">def</span> <span class="pl-en">denorm_query</span>(<span class="pl-s1">self</span>, <span class="pl-s1">index</span>, <span class="pl-s1">norm_value</span>):
        <span class="pl-s1">range</span> <span class="pl-c1">=</span> <span class="pl-s1">self</span>.<span class="pl-c1">train_max</span>[<span class="pl-s1">index</span>] <span class="pl-c1">-</span> <span class="pl-s1">self</span>.<span class="pl-c1">train_min</span>[<span class="pl-s1">index</span>]
        <span class="pl-k">return</span> <span class="pl-s1">norm_value</span> <span class="pl-c1">*</span> <span class="pl-s1">range</span> <span class="pl-c1">+</span> <span class="pl-s1">self</span>.<span class="pl-c1">train_min</span>[<span class="pl-s1">index</span>]</pre></div></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://Esgwg.github.io/ikun.github.io">Es</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","Esgwg/ikun.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
